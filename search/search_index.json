{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyAlicat","text":"<p>Python API for acquisition and control of Alicat mass flow meters and controllers.</p> <p>See Alicat Serial Communications Guide for reference</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install -U pyAlicat\n</code></pre> <p>or install with <code>Poetry</code></p> <pre><code>poetry add pyAlicat\n</code></pre>"},{"location":"#makefile-usage","title":"Makefile usage","text":"<p><code>Makefile</code> contains a lot of functions for faster development.</p> 1. Download and remove Poetry <p>  To download and install Poetry run:  <pre><code>make poetry-download\n</code></pre>  To uninstall  <pre><code>make poetry-remove\n</code></pre> </p> 2. Install all dependencies and pre-commit hooks <p>  Install requirements:  <pre><code>make install\n</code></pre>  Pre-commit hooks coulb be installed after `git init` via  <pre><code>make pre-commit-install\n</code></pre> </p> 3. Codestyle <p>  Automatic formatting uses `pyupgrade`, `isort` and `black`.  <pre><code>make codestyle\n\n# or use synonym\nmake formatting\n</code></pre>  Codestyle checks only, without rewriting files:  <pre><code>make check-codestyle\n</code></pre>  &gt; Note: `check-codestyle` uses `isort`, `black` and `darglint` library  Update all dev libraries to the latest version using one comand  <pre><code>make update-dev-deps\n</code></pre> 4. Code security <p> <pre><code>make check-safety\n</code></pre>  This command launches `Poetry` integrity checks as well as identifies security issues with `Safety` and `Bandit`.  <pre><code>make check-safety\n</code></pre> </p> </p> 5. Type checks <p>  Run `mypy` static type checker  <pre><code>make mypy\n</code></pre> </p> 6. Tests with coverage badges <p>  Run `pytest`  <pre><code>make test\n</code></pre> </p> 7. All linters <p>  Of course there is a command to ~~rule~~ run all linters in one:  <pre><code>make lint\n</code></pre>  the same as:  <pre><code>make test &amp;&amp; make check-codestyle &amp;&amp; make mypy &amp;&amp; make check-safety\n</code></pre> </p> 8. Docker <p> <pre><code>make docker-build\n</code></pre>  which is equivalent to:  <pre><code>make docker-build VERSION=latest\n</code></pre>  Remove docker image with  <pre><code>make docker-remove\n</code></pre>  More information [about docker](https://github.com/ulfsri/pyAlicat/tree/main/docker).  </p> 9. Cleanup <p> Delete pycache files  <pre><code>make pycache-remove\n</code></pre>  Remove package build  <pre><code>make build-remove\n</code></pre>  Delete .DS_STORE files  <pre><code>make dsstore-remove\n</code></pre>  Remove .mypycache  <pre><code>make mypycache-remove\n</code></pre>  Or to remove all above run:  <pre><code>make cleanup\n</code></pre> </p>"},{"location":"#releases","title":"\ud83d\udcc8 Releases","text":"<p>You can see the list of available releases on the GitHub Releases page.</p> <p>We follow Semantic Versions specification.</p> <p>We use <code>Release Drafter</code>. As pull requests are merged, a draft release is kept up-to-date listing the changes, ready to publish when you\u2019re ready. With the categories option, you can categorize pull requests in release notes using labels.</p>"},{"location":"#list-of-labels-and-corresponding-titles","title":"List of labels and corresponding titles","text":"Label Title in Releases <code>enhancement</code>, <code>feature</code> \ud83d\ude80 Features <code>bug</code>, <code>refactoring</code>, <code>bugfix</code>, <code>fix</code> \ud83d\udd27 Fixes &amp; Refactoring <code>build</code>, <code>ci</code>, <code>testing</code> \ud83d\udce6 Build System &amp; CI/CD <code>breaking</code> \ud83d\udca5 Breaking Changes <code>documentation</code> \ud83d\udcdd Documentation <code>dependencies</code> \u2b06\ufe0f Dependencies updates <p>You can update it in <code>release-drafter.yml</code>.</p> <p>GitHub creates the <code>bug</code>, <code>enhancement</code>, and <code>documentation</code> labels for you. Dependabot creates the <code>dependencies</code> label. Create the remaining labels on the Issues tab of your GitHub repository, when you need them.</p>"},{"location":"#license","title":"\ud83d\udee1 License","text":"<p>This project is licensed under the terms of the <code>MIT</code> license. See LICENSE for more details.</p>"},{"location":"#citation","title":"\ud83d\udcc3 Citation","text":"<pre><code>@misc{pyAlicat,\n  author = {ulfsri},\n  title = {Python API for acquisition and control of Alicat mass flow meters and controllers},\n  year = {2024},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  howpublished = {\\url{https://github.com/ulfsri/pyAlicat}}\n}\n</code></pre>"},{"location":"#credits","title":"Credits","text":"<p>This project was generated with <code>python-package-template</code></p> <p>Logo design by Natalya England</p>"},{"location":"device-reference/","title":"Device module","text":"<p>This module contains the Device class and its subclasses.</p> <p>Raises:</p> Type Description <code>VersionError</code> <p>Raised when the version of the device does not support command.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The dictionary of devices with the updated values.</p>"},{"location":"device-reference/#pyalicat.device.Device","title":"<code>Device</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Generic device class.</p> Source code in <code>pyalicat/device.py</code> <pre><code>class Device(ABC):\n    \"\"\"Generic device class.\"\"\"\n\n    @classmethod\n    @abstractmethod\n    def is_model(cls, model: str) -&gt; bool:\n        \"\"\"Determines if the model is the correct model for the device.\n\n        Args:\n            model (str): The model to check.\n\n        Returns:\n            bool: True if the model is correct, False otherwise.\n        \"\"\"\n        pass\n\n    def __init__(\n        self,\n        device: SerialDevice,\n        dev_info: dict[str, str],\n        id: str = \"A\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize the Device object.\n\n        Args:\n            device (SerialDevice): The SerialDevice object.\n            dev_info (dict): The device information dictionary.\n            id (str, optional): The device ID. Defaults to \"A\".\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        self._device = device\n        self._id = id\n        self._dev_info = dev_info\n        self._df_units = None\n        self._df_format = None\n        self._vers = float(\n            re.compile(r\"[0-9]+v[0-9]+\")\n            .findall(dev_info[\"software\"])[0]\n            .replace(\"v\", \".\")\n        )\n\n    @classmethod\n    async def new_device(cls, port: str, id: str = \"A\", **kwargs: Any) -&gt; Self:\n        \"\"\"Creates a new device. Chooses appropriate device based on characteristics.\n\n        Example:\n            dev = run(Device.new_device, '/dev/ttyUSB0')\n\n        Args:\n            port (str): The port the device is connected to.\n            id (str): The id of the device. Default is \"A\".\n            **kwargs: Any\n\n        Returns:\n            Device: The new device.\n        \"\"\"\n        if port.startswith(\"/dev/\"):\n            device = SerialDevice(port, **kwargs)\n        dev_info_ret = await device._write_readall(f\"{id}??M*\")\n        if not dev_info_ret:\n            raise ValueError(\"No device found on port\")\n        INFO_KEYS = (\n            \"manufacturer\",\n            \"website\",\n            \"phone\",\n            \"website\",\n            \"model\",\n            \"serial\",\n            \"manufactured\",\n            \"calibrated\",\n            \"calibrated_by\",\n            \"software\",\n        )\n        try:\n            dev_info = dict(\n                zip(\n                    INFO_KEYS,\n                    [i[re.search(r\"M\\d\\d\", i).end() + 1 :] for i in dev_info_ret],\n                )\n            )\n        except AttributeError:\n            raise ValueError(\"No device found on port\")\n        for cls in all_subclasses(Device):\n            if cls.is_model(dev_info[\"model\"]):\n                new_cls = cls(device, dev_info, id, **kwargs)\n                await new_cls.get_df_format()\n                return new_cls\n        raise ValueError(f\"Unknown device model: {dev_info['model']}\")\n\n    async def poll(self) -&gt; dict[str, str | float]:\n        \"\"\"Gets the current measurements of the device in defined data frame format.\n\n        Example:\n            df = run(dev.poll)\n\n        Returns:\n            dict[str, str | float]: The current measurements of the device from defined data frame format.\n        \"\"\"\n        # Gets the format of the dataframe if it is not already known\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(self._id)\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def request(\n        self, stats: list[str] | None = None, time: int = 1\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets requested measurements averaged over specified time.\n\n        Example:\n            df = run(dev.request, ['Mass_Flow', 'Abs_Press'], 1000)\n\n        Args:\n            stats (list[str]): Names of the statistics to get. Maximum of 13 statistics in one call.\n            time (int): The time to average over in milliseconds. Default is 1.\n\n        Returns:\n            dict[str, str | float]: The requested statistics.\n        \"\"\"\n        if stats is None:\n            stats = []\n        if len(stats) &gt; 13:\n            raise IndexError(\"Too many statistics requested\")\n            # stats = stats[:13]\n        ret = await self._device._write_readline(\n            f\"{self._id}DV {time} {' '.join(str(statistics[stat]) for stat in stats)}\"  # add a parameter for time out here\n        )\n        ret = ret.split()\n        for idx in range(len(ret)):\n            try:\n                ret[idx] = float(ret[idx])\n            except ValueError:\n                pass\n            if ret[idx] == \"--\":\n                ret[idx] = None\n        return dict(zip(stats, ret))\n\n    async def start_stream(self) -&gt; None:\n        \"\"\"Starts streaming data from device.\"\"\"\n        await self._device._write(f\"{self._id}@ @\")\n        return\n\n    async def stop_stream(self, new_id: str | None = None) -&gt; None:\n        \"\"\"Stops streaming data from device.\n\n        Example:\n            df = run(dev.stop_stream, 'B')\n\n        Args:\n            new_id (str): New device ID if desired. Will default to current ID if not given.\n        \"\"\"\n        if new_id is None:\n            new_id = self._id\n        await self._device._write(f\"@@ {new_id}\")\n        self.id = new_id\n        return\n\n    async def gas(\n        self, gas: str | None = None, save: bool | None = None\n    ) -&gt; dict[str, str]:\n        \"\"\"Gets/Sets the gas of the device.\n\n        Example:\n            df = run(dev.gas, 'N2', True)\n\n        Note:\n            Devices with firmware versions 10.05 or greater should use this method\n\n        Args:\n            gas (str): Name of the gas to set on the device.\n            save (bool): If true, will apply this gas on powerup.\n\n        Returns:\n            dict[str, str]: Reports the gas and its code and names.\n        \"\"\"\n        LABELS = (\"Unit_ID\", \"Gas_Code\", \"Gas\", \"Gas_Long\")\n        if gas and self._vers and self._vers &lt; 10.05:\n            warnings.warn(\"Version earlier than 10v05, running Set Gas\")\n            return await self._set_gas(gas)\n        gas = gases.get(gas, \"\")\n        if not gas:\n            save = None\n        if isinstance(save, bool):\n            savestr = \"1\" if save else \"0\"\n        ret = await self._device._write_readline(f\"{self._id}GS {gas or \"\"} {savestr}\")\n        return dict(zip(LABELS, ret.split()))\n\n    async def _set_gas(self, gas: str | None = None) -&gt; dict[str, str]:\n        \"\"\"Sets the gas of the device.\n\n        Example:\n            df = run(dev._set_gas, 'N2')\n\n        Note:\n            Devices with firmware versions lower than 10v05 should use this method\n\n        Args:\n            gas (str): Name of the gas to set on the device.\n\n        Returns:\n            dict[str, str]: Dataframe with new gas.\n        \"\"\"\n        if self._vers and self._vers &gt;= 10.05:\n            # print(\"Error: Version later than 10v05, running Active Gas\")\n            warnings.warn(\"Version later than 10v05, running Active Gas\")\n            return await self.gas(gas)\n        if self._df_format is None:\n            await self.get_df_format()\n        gas = gases.get(gas, \"\")\n        ret = await self._device._write_readline(f\"{self._id}G {gas or \"\"}\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def gas_list(self) -&gt; dict[str, str]:\n        \"\"\"Gets the list of available gases for the device.\n\n        Example:\n            df = run(dev.gas_list)\n\n        Returns:\n            dict[str, str]: List of all gas codes and their names.\n        \"\"\"\n        ret = {}\n        resp = await self._device._write_readall(f\"{self._id}??G*\")\n        for gas in resp:\n            gas = gas.split()\n            ret[gas[1]] = gas[2]\n        return ret\n\n    async def tare_abs_P(self) -&gt; dict[str, str | float]:\n        \"\"\"Tares the absolute pressure of the device, zeros out the absolute pressure reference point.\n\n        Should only be used when no flow and line is not pressurized.\n\n        Example:\n            df = run(dev.tare_abs_P)\n\n        Note:\n            **Untested.**\n\n        Returns:\n            dict[str, str | float]: Dataframe with zero absolute pressure\n        \"\"\"\n        # Gets the format of the dataframe if it is not already known\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(f\"{self._id}PC\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def tare_flow(self) -&gt; dict[str, str | float]:\n        \"\"\"Creates a no-flow reference point.\n\n        Should only be used when no flow and at operation pressure.\n\n        Example:\n            df = run(dev.tare_flow)\n\n        Note:\n            **Untested.**\n\n        Returns:\n            dict[str, str | float]: Dataframe with zero flow.\n        \"\"\"\n        # Gets the format of the dataframe if it is not already known\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(f\"{self._id}V\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def tare_gauge_P(self) -&gt; dict[str, str | float]:\n        \"\"\"Tares the gauge pressure of the device or differential pressure reference point.\n\n        Should only be used when no flow and open to atmosphere.\n\n        Example:\n            df = run(dev.tare_guage_P)\n\n        Note:\n            **Untested.**\n\n        Returns:\n            dict[str, str | float]: Dataframe with zero guage pressure.\n        \"\"\"\n        # Gets the format of the dataframe if it is not already known\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(f\"{self._id}P\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def auto_tare(\n        self, enable: bool | None = None, delay: float | None = None\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets/Sets if the controller auto tares.\n\n        Example:\n            df = run(dev.auto_tare, False, 0.0)\n\n        Note:\n            **Untested: Sets if the controller auto tares.**\n\n        Args:\n            enable (bool): Enable or disable auto tare\n            delay (float): Amount of time in seconds waited until tare begins 0.1 to 25.5\n\n        Returns:\n            dict[str, str | float]: If tare is active or not and delay length in seconds\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            # print(\"Error: Version earlier than 10v05\")\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Auto-tare\", \"Delay_(s)\")\n        enable_str = (\n            \"1\" if enable else \"0\" if enable is not None else \"\"\n        )  # Converts boolean to string or empty string if None\n        delay_str = (\n            f\"{delay:.1f}\" if delay is not None else \"\"\n        )  # Converts float to string or empty string if None\n        ret = await self._device._write_readline(\n            f\"{self._id}ZCA {enable_str} {delay_str}\"\n        )\n        ret = ret.split()\n        output_mapping = {\"1\": \"Enabled\", \"0\": \"Disabled\"}\n        ret[1] = output_mapping.get(str(ret[1]), ret[1])\n        ret[2] = float(ret[2])\n        return dict(zip(LABELS, ret))\n\n    async def configure_data_frame(self, format: int) -&gt; dict[str, str | float]:\n        \"\"\"Sets data frame's format.\n\n        Example:\n            df = run(dev.configure_data_frame, 0)\n\n        Args:\n            format (int): What format to set the data frame to.\n\n                - 0 for default: Values have 5 digits, setpoint and totalizer unsigned\n                - 1 for setpoint and totalizer signed (+ or -)\n                - 2 for signed setpoint and totalizer, number digits based on resolution\n\n        Returns:\n            dict[str, str | float]: Data Frame in new format\n        \"\"\"\n        if self._vers and self._vers &lt; 6.00:\n            raise VersionError(\"Version earlier than 6v00\")\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(f\"{self._id}FDF {format}\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def _engineering_units(\n        self,\n        statistic_value: str,\n        unit: str | None = None,\n        group: bool | None = None,\n        override: bool | None = None,\n    ) -&gt; dict[str, str]:\n        \"\"\"Gets/Sets units for desired statistics.\n\n        Example:\n            df = run(dev.engineering_units, \"Mass_Flow\", False, \"SCCM\", False)\n\n        Args:\n            statistic_value (str): Desired statistic to get/set unit for\n            group (bool): If setting unit, sets to entire group statisitc is in\n            unit (str): Sets unit for statistic\n            override (bool): Overwrites any special rules for group changes.\n\n                - False for not changing special rules\n                - True for applying the new units to all statistics in the group.\n\n        Returns:\n            dict[str, str]: Responds with unit\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Unit_Code\", \"Unit_Label\")\n        group_str = (\n            \"1\" if group else \"0\" if group is not None else \"\"\n        )  # Converts boolean to string or empty string if None\n        override_str = (\n            \"1\" if override else \"0\" if override is not None else \"\"\n        )  # Converts boolean to string or empty string if None\n        ret = await self._device._write_readline(\n            f\"{self._id}DCU {statistics[statistic_value]} {units[unit]} {group_str} {override_str}\"\n        )\n        ret = ret.split()\n        return dict(zip(LABELS, ret))\n\n    async def flow_press_avg(\n        self,\n        stat_val: str | int,\n        avg_time: int | None = None,\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets/Set the length of time a statistic is averaged over.\n\n        Example:\n            df = run(dev.flow_press_avg, \"Mass_Flow\")\n\n        Args:\n            stat_val (str): Desired statistic to get average/set time\n            avg_time (int): Time in milliseconds over which averages taken. Ranges from 0 to 9999. If 0, the deivce updates every millisecond.\n\n        Returns:\n            dict[str, str | float]: Responds value of queried average and avg time const\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Value\", \"Time_Const\")\n        if stat_val.upper() == \"ALL\":\n            stat_val = 1\n        else:\n            stat_val = statistics[stat_val]\n        ret = await self._device._write_readline(\n            f\"{self._id}DCA {stat_val} {avg_time or \"\"}\"\n        )\n        ret = ret.split()\n        ret[1] = int(ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def full_scale_val(\n        self, stat_val: str | int, unit: str | None = None\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets measurement range of given statistic.\n\n        Example:\n            df = run(dev.full_scale_val, 'Mass_Flow', 'SCCM')\n\n        Args:\n            stat_val (str): Desired statistic to get range\n            unit (str): Units of range. Defaults if left blank.\n\n        Returns:\n            dict[str, str | float]: Responds max value of statistic and units\n        \"\"\"\n        if self._vers and self._vers &lt; 6.00:\n            raise VersionError(\"Version earlier than 6v00\")\n        LABELS = (\"Unit_ID\", \"Max_Value\", \"Unit_Code\", \"Unit_Label\")\n        if unit is None:\n            unit = \"\"\n        ret = await self._device._write_readline(\n            f\"{self._id}FPF {statistics[stat_val]} {units[unit]}\"\n        )\n        ret = ret.split()\n        ret[1] = float(ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def power_up_tare(self, enable: bool | None = None) -&gt; dict[str, str]:\n        \"\"\"Gets/Sets if device tares on power-up.\n\n        Example:\n            df = run(dev.power_up_tare, False)\n\n        Args:\n            enable (bool): If Enabled, 0.25 second after sensors stable. Close loop delay, valves stay closed\n\n        Returns:\n            dict[str, str]: If tare is enabled\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Power-Up_Tare\")\n        enable_str = \"1\" if enable else \"0\" if enable is not None else \"\"\n        ret = await self._device._write_readline(f\"{self._id}ZCP {enable_str}\")\n        ret = ret.split()\n        output_mapping = {\"1\": \"Enabled\", \"0\": \"Disabled\"}\n        ret[1] = output_mapping.get(str(ret[1]), ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def data_frame(self) -&gt; list[str]:\n        \"\"\"Gets info about current data frame.\n\n        Example:\n            df = run(dev.data_frame)\n\n        Returns:\n            str: table that outlines data frame format\n        \"\"\"\n        if self._vers and self._vers &lt; 6.00:\n            raise VersionError(\"Version earlier than 6v00\")\n        ret = await self._device._write_readall(f\"{self._id}??D*\")\n        return ret\n\n    async def stp_press(\n        self, stp: str = \"S\", unit: str | None = None, press: float | None = None\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets/Sets standard or normal pressure reference point.\n\n        To get Normal pressure reference point, set stp to N.\n\n        Example:\n            df = run(dev.stp_press, 'S', 'PSIA', 14.69595)\n\n        Args:\n            stp (str): S for standard pressure, N for normal\n            unit (str): Pressure units\n            press (float): Numeric value of new desired pressure reference point\n\n        Returns:\n            dict[str, str | float]: Current pressure reference point and units\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Curr_Press_Ref\", \"Unit_Code\", \"Unit_Label\")\n        if stp.upper() == \"NTP\":\n            stp = \"N\"\n        if stp.upper() != \"N\":\n            stp = \"S\"\n        if unit is None:\n            unit = \"\"\n        ret = await self._device._write_readline(\n            f\"{self._id}DCFRP {stp.upper()} {str(units[unit])} {press or \"\"}\"\n        )\n        ret = ret.split()\n        ret[1] = float(ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def stp_temp(\n        self, stp: str = \"S\", unit: str | None = None, temp: float | None = None\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets/Sets standard or normal temperature reference point.\n\n        To get Normal temperature reference point, set stp to N.\n\n        Example:\n            df = run(dev.stp_temp, 'S', 'C', 25.0)\n\n        Args:\n            stp (str): S for standard temperature, N for normal\n            unit (str): Temperature units\n            temp (float): Numeric value of new desired temperature reference point\n\n        Returns:\n            dict[str, str | float]: Current temperature reference point and units\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Curr_Temp_Ref\", \"Unit_Code\", \"Unit_Label\")\n        if stp.upper() == \"NTP\":\n            stp = \"N\"\n        if stp.upper() != \"N\":\n            stp = \"S\"\n        if unit is None:\n            unit = \"\"\n        ret = await self._device._write_readline(\n            f\"{self._id}DCFRT {stp.upper()} {str(units[unit])} {temp or \"\"}\"\n        )\n        ret = ret.split()\n        ret[1] = float(ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def zero_band(self, zb: float | int | None = None) -&gt; dict[str, str | float]:\n        \"\"\"Gets/Sets the zero band of the device.\n\n        Example:\n            df = run(dev.zero_band, 0.0)\n\n        Args:\n            zb (float): % of full-scale readings process must exceed before device reports readings\n\n                - 0 to 6.38 range\n                - 0 to disable\n\n        Returns:\n            dict[str, str | float]: Returns current zero band as percent of full scale\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Zero_Band_(%)\")\n        zb_str = f\"0 {zb:.2f}\" if zb is not None else \"\"\n        ret = await self._device._write_readline(f\"{self._id}DCZ {zb_str}\")\n        ret = ret.split()\n        ret.pop(1)\n        ret[1] = float(ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def analog_out_source(\n        self, primary: str | int = 0, val: str | None = None, unit: str | None = None\n    ) -&gt; dict[str, str]:\n        \"\"\"Gets/Sets the source of the analog output.\n\n        Example:\n            df = run(dev.analog_out_source, \"PRIMARY\", \"Mass_Flow\", \"SCCM\")\n\n        Args:\n            primary (int): Primary or secondary analog output. 0 for primary, 1 for secondary\n            val (str): Statistic being tracked\n                - 'MAX' to fix min possible output\n                - 'MIN' to fix max possible output\n                - Other for statistic\n            unit (str): Desired unit. Optional\n\n        Returns:\n            dict[str, str]: Statistic and units\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Value\", \"Unit_Code\", \"Unit_Label\")\n        if isinstance(primary, str):\n            if primary.upper() == \"SECONDARY\" or primary.upper() == \"2ND\":\n                primary = \"1\"\n        if val is not None:\n            if val.upper() == \"MAX\":\n                val = \"0\"\n            elif val.upper() == \"MIN\":\n                val = \"1\"\n            else:\n                val = str(statistics[val])\n        if unit is not None:\n            unit = str(units[unit])\n        ret = await self._device._write_readline(\n            f\"{self._id}ASOCV {primary} {val or \"\"} {unit or \"\"}\"\n        )\n        ret = ret.split()\n        if ret[1] == \"0\":\n            ret[1] = \"Max\"\n        elif ret[1] == \"1\":\n            ret[1] = \"Min\"\n        else:\n            for stat in statistics:\n                if str(statistics[stat]) == ret[1]:\n                    ret[1] = stat  # This is not necessarily the correct code\n                    break\n        return dict(zip(LABELS, ret))\n\n    async def baud(self, new_baud: int | None = None) -&gt; dict[str, str | float]:\n        \"\"\"Gets/Sets the baud rate of the device.\n\n        Example:\n            df = run(dev.baud, 9600)\n\n        Note:\n            Ensure COM is connected.\n\n        Args:\n            new_baud (int): Set to one of the following:\n\n                - 2400 4800, 9600, 19200, 38400, 57600, 115200\n\n                After baud is changed, communication MUST be re-established.\n\n        Returns:\n            dict[str, str | float]: Baud rate, either current or new\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Baud\")\n        VALID_BAUD_RATES = (2400, 4800, 9600, 19200, 38400, 57600, 115200)\n        if new_baud is not None and int(new_baud) not in VALID_BAUD_RATES:\n            raise ValueError(\"Invalid baud rate\")\n        ret = await self._device._write_readline(f\"{self._id}NCB {new_baud or \"\"}\")\n        ret = ret.split()\n        ret[1] = int(ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def blink(self, dur: int | None = None) -&gt; dict[str, str]:\n        \"\"\"Blinks the device. Gets the blinking state.\n\n        Example:\n            df = run(dev.blink, 10)\n\n        Args:\n           dur (int): Duration devices flashes in seconds.\n            - 0 stops blinking.\n            - -1 to flash indefinitely.\n\n        Returns:\n            dict[str, str]: If the display is currently blinking\n        \"\"\"\n        if self._vers and self._vers &lt; 8.28:\n            raise VersionError(\"Version earlier than 8v28\")\n        LABELS = (\"Unit_ID\", \"Flashing?\")\n        ret = await self._device._write_readline(f\"{self._id}FFP {dur or \"\"}\")\n        ret = ret.split()\n        output_mapping = {\"1\": \"Yes\", \"0\": \"No\"}\n        ret[1] = output_mapping.get(str(ret[1]), ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def change_unit_id(self, new_id: str) -&gt; None:\n        \"\"\"Sets the unit ID of the device.\n\n        Example:\n            df = run(dev.change_unit_id, \"B\")\n\n        Note:\n            **This changes the ID, but the device stops responding**.\n\n        Args:\n            new_id (str): New ID for the device. A-Z accepted\n        \"\"\"\n        if new_id.upper() not in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n            raise ValueError(\"Invalid ID\")\n        await self._device._write(f\"{self._id}@ {new_id}\")\n        self._id = new_id\n        return\n\n    async def firmware_version(self) -&gt; dict[str, str]:\n        \"\"\"Gets the firmware version of the device.\n\n        Example:\n            df = run(dev.firmware_version)\n\n        Returns:\n            dict[str, str]: Current firmware vesion and its date of creation\n        \"\"\"\n        LABELS = (\"Unit_ID\", \"Vers\", \"Creation_Date\")\n        ret = await self._device._write_readline(f\"{self._id}VE\")\n        ret = ret.split()\n        ret[2] = \" \".join(ret[2:])\n        self._vers = float(ret[1][:-4].replace(\".\", \"\").replace(\"v\", \".\"))\n        return dict(zip(LABELS, ret))\n\n    async def lock_display(self) -&gt; dict[str, str | float]:\n        \"\"\"Disables buttons on front of the device.\n\n        Example:\n            df = run(dev.lock_display)\n\n        Returns:\n            dict[str, str | float]: Data frame with lock status enabled\n        \"\"\"\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(f\"{self._id}L\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def manufacturing_info(self) -&gt; list[str]:\n        \"\"\"Gets info about device.\n\n        Returns:\n            list[str]: Info on device, model, serial number, manufacturing, calibration, software\n        \"\"\"\n        ret = await self._device._write_readall(f\"{self._id}??M*\")\n        return ret\n\n    async def remote_tare(\n        self, actions: list[str] | None = None\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets/Sets the remote tare value.\n\n        Example:\n            df = run(dev.remote_tare, [\"Primary Press\", \"Secondary Press\"])\n\n        Note:\n            This usually only works on meters and gauges. Not all devices support this.\n\n        Note:\n            **Untested: Sets the remote tare effect.**\n\n        Args:\n            actions (list[str]): Actions to perform\n\n        Returns:\n            dict[str, str | float]: Total value of active actions\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Active_Actions_Total\")\n        if actions is None:\n            actions = []\n        action_dict = {\n            \"Primary_Press\": 1,\n            \"Secondary_Press\": 2,\n            \"Flow\": 4,\n            \"Reset_Totalizer_1\": 8,\n            \"Reset_Totalizer_2\": 16,\n        }\n        act_tot: int | None = sum([action_dict.get(act, 0) for act in actions])\n        if not actions:\n            act_tot = None\n        ret = await self._device._write_readline(f\"{self._id}ASRCA {act_tot or \"\"}\")\n        ret = ret.split()\n        ret[1] = int(ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def restore_factory_settings(self) -&gt; str:\n        \"\"\"Restores factory settings of the device.\n\n        Removes any calibrations.\n\n        Example:\n            df = run(dev.restore_factory_settings)\n\n        Note:\n            **Untested.**\n\n        Returns:\n            Confirmation of restoration\n        \"\"\"\n        if self._vers and self._vers &lt; 7.00:\n            raise VersionError(\"Version earlier than 7v00\")\n        ret = await self._device._write_readline(f\"{self._id}FACTORY RESTORE ALL\")\n        return ret\n\n    async def user_data(self, slot: int, val: str | None = None) -&gt; dict[str, str]:\n        \"\"\"Gets/Sets user data in slot.\n\n        Gets the user data from the string is slot.\n        Sets the user data in slot to val.\n\n        Example:\n            df = run(dev.user_data, 0, \"New Value\")\n\n        Args:\n            slot (int): Slot number, 0 to 3\n            val (str): 32-char ASCII string. Must be encoded.\n\n        Returns:\n            dict[str, str]: Value in called slot (either new or read)\n        \"\"\"\n        if self._vers and self._vers &lt; 8.24:\n            raise VersionError(\"Version earlier than 8v24\")\n        if val is None:\n            LABELS = (\"Unit_ID\", \"Curr_Value\")\n        else:\n            LABELS = (\"Unit_ID\", \"New_Value\")\n        ret = await self._device._write_readline(f\"{self._id}UD {slot} {val or \"\"}\")\n        ret = ret.split()\n        return dict(zip(LABELS, ret))\n\n    async def streaming_rate(\n        self, interval: int | None = None\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets/Sets the streaming rate of the device.\n\n        Example:\n            df = run(dev.streaming_rate, 50)\n\n        Args:\n            interval (int): Streaming rate in milliseconds between data frames\n\n        Returns:\n            dict[str, str | float]: Interval of streaming rate\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Interval_(ms)\")\n        ret = await self._device._write_readline(f\"{self._id}NCS {interval or \"\"}\")\n        ret = ret.split()\n        ret[1] = int(ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def unlock_display(self) -&gt; dict[str, str | float]:\n        \"\"\"Enables buttons on front of the device.\n\n        Example:\n            df = run(dev.unlock_display)\n\n        Returns:\n            dict[str, str | float]: Data frame with LCK disabled\n        \"\"\"\n        # Gets the format of the dataframe if it is not already known\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(f\"{self._id}U\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def create_gas_mix(\n        self, name: str, number: int, gas_dict: dict[str, float] = {}\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Sets custom gas mixture.\n\n        This only works with specific gas codes so far\n\n        Example:\n            df = run(dev.query_gas_mix, \"My Gas\", 255, {\"O2\": 20.0, \"N2\": 80.0})\n\n        Note:\n            **Untested**\n\n        Args:\n            name (str): Name of custom mixture\n            number (int): 236 to 255. Gas is saved to this number\n            gas_dict (dict[str, float]): Gas name : Percentage of Mixture. Maximum of 5 gases. Percent is Molar\n                            percent up to 2 decimals. Total percentages must sum to 100.00%\n\n        Returns:\n            dict: Gas number of new mix and percentages and names of each constituent\n        \"\"\"\n        if self._vers and self._vers &lt; 5.00:\n            raise VersionError(\"Version earlier than 5v00\")\n        if len(gas_dict) &gt; 5:\n            raise IndexError(\"Too many input gases\")\n        gas_string = \"\"\n        for x in gas_dict:\n            gas_string += f\" {gas_dict[x]} {gases[x]}\"\n\n        LABELS = (\n            \"Unit_ID\",\n            \"Gas_Num\",\n            \"Gas1_Name\",\n            \"Gas1_Perc\",\n            \"Gas2_Name\",\n            \"Gas2_Perc\",\n            \"Gas3_Name\",\n            \"Gas3_Perc\",\n            \"Gas4_Name\",\n            \"Gas4_Perc\",\n            \"Gas5_Name\",\n            \"Gas5_Perc\",\n        )\n        ret = await self._device._write_readline(\n            f\"{self._id}GM {name} {number} {gas_string}\"\n        )\n        ret = ret.split()\n        return dict(zip(LABELS, ret))\n\n    async def delete_gas_mix(self, gasN: str = \"\") -&gt; dict[str, float]:\n        \"\"\"Deletes custom gas mixture.\n\n        Example:\n            df = run(dev.delete_gas_mix, 255)\n\n        Note:\n            **Nonfunctional**\n\n        Args:\n            gasN (str): Number of gas to delete\n\n        Returns:\n            dict[str, float]: Deleted gas' number\n        \"\"\"\n        if self._vers and self._vers &lt; 5.00:\n            raise VersionError(\"Version earlier than 5v00\")\n        LABELS = (\"Unit_ID\", \"Deleted_Gas_Num\")\n        ret = await self._device._write_readline(f\"{self._id}GD {gasN}\")\n        ret = ret.split()\n        return dict(zip(LABELS, ret))\n\n    async def query_gas_mix(self, gasN: int) -&gt; dict[str, str]:\n        \"\"\"Gets percentages of gases in mixture.\n\n        Example:\n            df = run(dev.query_gas_mix, 255)\n\n        Args:\n           gasN (int): Number of the custom gas to analyze\n\n        Returns:\n            dict[str, str]: Gas numbers and their percentages in mixture\n        \"\"\"\n        if self._vers and self._vers &lt; 9.00:\n            raise VersionError(\"Version earlier than 9v00\")\n        LABELS = (\n            \"Unit_ID\",\n            \"Gas_Num\",\n            \"Gas1_Name\",\n            \"Gas1_Perc\",\n            \"Gas2_Name\",\n            \"Gas2_Perc\",\n            \"Gas3_Name\",\n            \"Gas3_Perc\",\n            \"Gas4_Name\",\n            \"Gas4_Perc\",\n            \"Gas5_Name\",\n            \"Gas5_Perc\",\n        )\n        ret = await self._device._write_readall(f\"{self._id}GC {gasN}\")\n        ret = ret[0].replace(\"=\", \" \").split()\n        for i in range(len(ret)):\n            if \"Name\" in LABELS[i]:\n                ret[i] = next(\n                    (code for code, value in gases.items() if value == int(ret[i])),\n                    ret[i],\n                )\n        return dict(zip(LABELS, ret))\n\n    async def config_totalizer(\n        self,\n        totalizer: int = 1,\n        flow_stat_val: str | None = None,\n        mode: int | None = None,\n        limit_mode: int | None = None,\n        num: int | None = None,\n        dec: int | None = None,\n    ) -&gt; dict[str, str]:\n        \"\"\"Enables/Disables and Configures totalizer.\n\n        Example:\n            df = run(dev.config_totalizer, totalizer=1, 1, -1, -1, 10, 0) # For ZTotalizer 1, disable, do not change, do not change, 10 digits, 0 decimals\n\n        Args:\n            totalizer (int): 1 or 2, which totalizer used\n            flow_stat_val (str): Statistic to measure. Use -1 to not change statistic, use 1 to disable\n            mode (int): Manages how to totalizer accumulates flow. -1 to 3\n\n                - -1 = Do not change\n                - 0 = add positive flow, ignore negative\n                - 1 = add negative flow, ignore positive\n                - 2 = add positive flow, subtract negative\n                - 3 = add positive flow until flow stops, then reset to 0\n            limit_mode (int): Manages what totalizer does when limit reached. -1 to 3\n\n                - -1 = Do not change\n                - 0 = Stop count and leave at max, does not set TOV error\n                - 1 = Rest to 0, continue count, does not set TOV error\n                - 2 = Stop count and leave at max, sets TOV error\n                - 3 = Reset to 0, continue count, sets TOV error\n            num (int): Value 7 to 10. How many digits in totalizer.\n            dec (int): 0 to 9. How many digits after decimal.\n\n        Returns:\n            dict[str, str]: Configuration of totalizer\n        \"\"\"\n        if self._vers and self._vers &lt; 10.00:\n            raise VersionError(\"Version earlier than 10v00\")\n        LABELS = (\n            \"Unit_ID\",\n            \"Totalizer\",\n            \"Flow_Stat_Val\",\n            \"Mode\",\n            \"Limit_Mode\",\n            \"Num_Digits\",\n            \"Dec_Place\",\n        )\n        if flow_stat_val != \"\":\n            flow_stat_val = statistics.get(flow_stat_val, -1)\n        ret = await self._device._write_readline(\n            f\"{self._id}TC {totalizer} {flow_stat_val or \"\"} {mode or \"\"} {limit_mode or \"\"} {num or \"\"} {dec or \"\"}\"\n        )\n        ret = ret.split()\n        return dict(zip(LABELS, ret))  # Need to convert codes to text\n\n    async def reset_totalizer(self, totalizer: int = 1) -&gt; dict[str, str | float]:\n        \"\"\"Returns totalizer count to zero and restarts timer.\n\n        Example:\n            df = run(dev.reset_totalizer, totalizer=1)\n\n        Note:\n            **Untested.**\n\n        Args:\n            totalizer (int): Which totalizer to reset: 1 or 2\n\n        Returns:\n            dict[str, str | float]: Dataframe with totalizer set to zero.\n        \"\"\"\n        if self._vers and self._vers &lt; 8.00:\n            raise VersionError(\"Version earlier than 8v00\")\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(f\"{self._id}T {totalizer}\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def reset_totalizer_peak(self, totalizer: int = 1) -&gt; dict[str, str | float]:\n        \"\"\"Resets peak flow rate that has been measured since last reset.\n\n        Example:\n            df = run(dev.reset_totalizer_peak, totalizer=1)\n\n        Note:\n            **Untested.**\n\n        Args:\n            totalizer (int): Which totalizer to reset: 1 or 2\n\n        Returns:\n            dict[str, str | float]: Data frame\n        \"\"\"\n        if self._vers and self._vers &lt; 8.00:\n            raise VersionError(\"Version earlier than 8v00\")\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(f\"{self._id}TP {totalizer}\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def save_totalizer(self, enable: bool | None = None) -&gt; dict[str, str]:\n        \"\"\"Enables/disables saving totalizer values at regular intervals.\n\n        If enabled, restore last saved totalizer on power-up.\n\n        Example:\n            df = run(dev.save_totalizer, enable=True)\n\n        Args:\n           enable (bool): Whether to enable or disable saving totalizer values on startup\n\n        Returns:\n            dict[str, str]: Says if totalizer is enabled or disabled\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Saving\")\n        enable_str = \"1\" if enable else \"0\" if enable is not None else \"\"\n        ret = await self._device._write_readline(f\"{self._id}TCR {enable_str}\")\n        ret = ret.split()\n        output_mapping = {\"1\": \"Enabled\", \"0\": \"Disabled\"}\n        ret[1] = output_mapping.get(str(ret[1]), ret[1])\n        return dict(zip(LABELS, ret))  # Need to convert codes to text\n\n    async def get_df_format(self) -&gt; list[list[str]]:\n        \"\"\"Gets the format of the current dataframe format of the device.\n\n        Example:\n            df = run(dev.get_df_format)\n\n        Returns:\n            list[list[str]]: Dataframe format\n        \"\"\"\n        resp = await self._device._write_readall(f\"{self._id}??D*\")\n        splits = []\n        for match in re.finditer(r\"\\s\", resp[0]):\n            splits.append(match.start())\n        df_table = [\n            [k[i + 1 : j] for i, j in zip(splits, splits[1:] + [None])] for k in resp\n        ]\n        df_format = [\n            i[[idx for idx, s in enumerate(df_table[0]) if \"NAME\" in s][0]].strip()\n            for i in df_table[1:-1]\n        ]\n        df_format = [i.replace(\" \", \"_\") for i in df_format]\n        df_ret = [\n            i[[idx for idx, s in enumerate(df_table[0]) if \"TYPE\" in s][0]].strip()\n            for i in df_table[1:-1]\n        ]\n        df_stand = [i for i in df_format if not (i.startswith(\"*\"))]\n        df_stand_ret = [i for i in df_ret[: len(df_stand)]]\n        self._df_format = df_format\n        self._df_ret = df_ret\n        return [df_stand, df_stand_ret]\n\n    async def get_units(self, stats: list[str]) -&gt; dict[str, str]:\n        \"\"\"Gets the units of the current dataframe format of the device.\n\n        Args:\n            stats (list): List of statistics to get units for.\n\n        Returns:\n            list: Units of statistics in measurement\n        \"\"\"\n        units = []\n        for stat in stats:\n            ret = await self._engineering_units(stat)\n            units.append(ret[\"Unit_Label\"])\n        return dict(zip(stats, units))\n\n    async def set_units(self, stats: dict[str, str]) -&gt; dict[str, str]:\n        \"\"\"Sets the units of the current dataframe format of the device.\n\n        Args:\n            stats (dict[str, str]): Dictionary of statistics and their units\n\n        Returns:\n            dict[str, str]: Units of statistics in measurement\n        \"\"\"\n        for stat in stats:\n            ret = await self._engineering_units(stat, stats[stat])\n            stats[stat] = ret[\"Unit_Label\"]\n        return stats\n\n    async def get(self, measurements: list[str] = [\"@\"]) -&gt; dict[str, str | float]:\n        \"\"\"Gets the value of a measurement from the device.\n\n        Args:\n            measurements (list[str]): List of measurements to get. If not specified, gets all measurements in standard dataframe.\n\n        Returns:\n            dict[str, str | float]: Dictionary of measurements and their values\n        \"\"\"\n        resp = {}\n        flag = 0\n        reqs = []\n        # Request\n        if not measurements:\n            measurements = [\"@\"]\n        for meas in measurements:\n            if meas in statistics:\n                reqs.append(meas)\n            elif meas.upper() == \"GAS\":\n                resp.update(await self.gas())\n            elif flag == 0:\n                resp.update(await self.poll())\n                flag = 1\n        i = 0\n        while i * 13 &lt; len(reqs):\n            resp.update(await self.request(reqs[13 * i : 13 + 13 * i]))\n            i += 1\n        return resp\n\n    async def set(self, comm: dict[str, list[str | float]]) -&gt; dict[str, str | float]:\n        \"\"\"Sets the values of measurements for the device.\n\n        Args:\n            comm (dict[str, str]): Dictionary with command to set as key, parameters as values. Use a list for multiple parameters\n\n        Returns:\n            dict[str, str: response of setting function\n        \"\"\"\n        resp: dict[str, str | float] = {}\n        for meas in list(comm.keys()):\n            upper_meas = str(meas).upper()\n            # Set gas - Param1 = gas: str = \"\", Param2 = save: bool = \"\"\n            if upper_meas == \"GAS\":\n                resp.update(await self.gas(str(comm[meas][0]), str(comm[meas][1])))\n        return resp\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.__init__","title":"<code>__init__(device, dev_info, id='A', **kwargs)</code>","text":"<p>Initialize the Device object.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>SerialDevice</code> <p>The SerialDevice object.</p> required <code>dev_info</code> <code>dict</code> <p>The device information dictionary.</p> required <code>id</code> <code>str</code> <p>The device ID. Defaults to \"A\".</p> <code>'A'</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>pyalicat/device.py</code> <pre><code>def __init__(\n    self,\n    device: SerialDevice,\n    dev_info: dict[str, str],\n    id: str = \"A\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize the Device object.\n\n    Args:\n        device (SerialDevice): The SerialDevice object.\n        dev_info (dict): The device information dictionary.\n        id (str, optional): The device ID. Defaults to \"A\".\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    self._device = device\n    self._id = id\n    self._dev_info = dev_info\n    self._df_units = None\n    self._df_format = None\n    self._vers = float(\n        re.compile(r\"[0-9]+v[0-9]+\")\n        .findall(dev_info[\"software\"])[0]\n        .replace(\"v\", \".\")\n    )\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.analog_out_source","title":"<code>analog_out_source(primary=0, val=None, unit=None)</code>  <code>async</code>","text":"<p>Gets/Sets the source of the analog output.</p> Example <p>df = run(dev.analog_out_source, \"PRIMARY\", \"Mass_Flow\", \"SCCM\")</p> <p>Parameters:</p> Name Type Description Default <code>primary</code> <code>int</code> <p>Primary or secondary analog output. 0 for primary, 1 for secondary</p> <code>0</code> <code>val</code> <code>str</code> <p>Statistic being tracked - 'MAX' to fix min possible output - 'MIN' to fix max possible output - Other for statistic</p> <code>None</code> <code>unit</code> <code>str</code> <p>Desired unit. Optional</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Statistic and units</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def analog_out_source(\n    self, primary: str | int = 0, val: str | None = None, unit: str | None = None\n) -&gt; dict[str, str]:\n    \"\"\"Gets/Sets the source of the analog output.\n\n    Example:\n        df = run(dev.analog_out_source, \"PRIMARY\", \"Mass_Flow\", \"SCCM\")\n\n    Args:\n        primary (int): Primary or secondary analog output. 0 for primary, 1 for secondary\n        val (str): Statistic being tracked\n            - 'MAX' to fix min possible output\n            - 'MIN' to fix max possible output\n            - Other for statistic\n        unit (str): Desired unit. Optional\n\n    Returns:\n        dict[str, str]: Statistic and units\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Value\", \"Unit_Code\", \"Unit_Label\")\n    if isinstance(primary, str):\n        if primary.upper() == \"SECONDARY\" or primary.upper() == \"2ND\":\n            primary = \"1\"\n    if val is not None:\n        if val.upper() == \"MAX\":\n            val = \"0\"\n        elif val.upper() == \"MIN\":\n            val = \"1\"\n        else:\n            val = str(statistics[val])\n    if unit is not None:\n        unit = str(units[unit])\n    ret = await self._device._write_readline(\n        f\"{self._id}ASOCV {primary} {val or \"\"} {unit or \"\"}\"\n    )\n    ret = ret.split()\n    if ret[1] == \"0\":\n        ret[1] = \"Max\"\n    elif ret[1] == \"1\":\n        ret[1] = \"Min\"\n    else:\n        for stat in statistics:\n            if str(statistics[stat]) == ret[1]:\n                ret[1] = stat  # This is not necessarily the correct code\n                break\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.auto_tare","title":"<code>auto_tare(enable=None, delay=None)</code>  <code>async</code>","text":"<p>Gets/Sets if the controller auto tares.</p> Example <p>df = run(dev.auto_tare, False, 0.0)</p> Note <p>Untested: Sets if the controller auto tares.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Enable or disable auto tare</p> <code>None</code> <code>delay</code> <code>float</code> <p>Amount of time in seconds waited until tare begins 0.1 to 25.5</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: If tare is active or not and delay length in seconds</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def auto_tare(\n    self, enable: bool | None = None, delay: float | None = None\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets/Sets if the controller auto tares.\n\n    Example:\n        df = run(dev.auto_tare, False, 0.0)\n\n    Note:\n        **Untested: Sets if the controller auto tares.**\n\n    Args:\n        enable (bool): Enable or disable auto tare\n        delay (float): Amount of time in seconds waited until tare begins 0.1 to 25.5\n\n    Returns:\n        dict[str, str | float]: If tare is active or not and delay length in seconds\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        # print(\"Error: Version earlier than 10v05\")\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Auto-tare\", \"Delay_(s)\")\n    enable_str = (\n        \"1\" if enable else \"0\" if enable is not None else \"\"\n    )  # Converts boolean to string or empty string if None\n    delay_str = (\n        f\"{delay:.1f}\" if delay is not None else \"\"\n    )  # Converts float to string or empty string if None\n    ret = await self._device._write_readline(\n        f\"{self._id}ZCA {enable_str} {delay_str}\"\n    )\n    ret = ret.split()\n    output_mapping = {\"1\": \"Enabled\", \"0\": \"Disabled\"}\n    ret[1] = output_mapping.get(str(ret[1]), ret[1])\n    ret[2] = float(ret[2])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.baud","title":"<code>baud(new_baud=None)</code>  <code>async</code>","text":"<p>Gets/Sets the baud rate of the device.</p> Example <p>df = run(dev.baud, 9600)</p> Note <p>Ensure COM is connected.</p> <p>Parameters:</p> Name Type Description Default <code>new_baud</code> <code>int</code> <p>Set to one of the following:</p> <ul> <li>2400 4800, 9600, 19200, 38400, 57600, 115200</li> </ul> <p>After baud is changed, communication MUST be re-established.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Baud rate, either current or new</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def baud(self, new_baud: int | None = None) -&gt; dict[str, str | float]:\n    \"\"\"Gets/Sets the baud rate of the device.\n\n    Example:\n        df = run(dev.baud, 9600)\n\n    Note:\n        Ensure COM is connected.\n\n    Args:\n        new_baud (int): Set to one of the following:\n\n            - 2400 4800, 9600, 19200, 38400, 57600, 115200\n\n            After baud is changed, communication MUST be re-established.\n\n    Returns:\n        dict[str, str | float]: Baud rate, either current or new\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Baud\")\n    VALID_BAUD_RATES = (2400, 4800, 9600, 19200, 38400, 57600, 115200)\n    if new_baud is not None and int(new_baud) not in VALID_BAUD_RATES:\n        raise ValueError(\"Invalid baud rate\")\n    ret = await self._device._write_readline(f\"{self._id}NCB {new_baud or \"\"}\")\n    ret = ret.split()\n    ret[1] = int(ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.blink","title":"<code>blink(dur=None)</code>  <code>async</code>","text":"<p>Blinks the device. Gets the blinking state.</p> Example <p>df = run(dev.blink, 10)</p> <p>Parameters:</p> Name Type Description Default <code>dur</code> <code>int</code> <p>Duration devices flashes in seconds. - 0 stops blinking. - -1 to flash indefinitely.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: If the display is currently blinking</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def blink(self, dur: int | None = None) -&gt; dict[str, str]:\n    \"\"\"Blinks the device. Gets the blinking state.\n\n    Example:\n        df = run(dev.blink, 10)\n\n    Args:\n       dur (int): Duration devices flashes in seconds.\n        - 0 stops blinking.\n        - -1 to flash indefinitely.\n\n    Returns:\n        dict[str, str]: If the display is currently blinking\n    \"\"\"\n    if self._vers and self._vers &lt; 8.28:\n        raise VersionError(\"Version earlier than 8v28\")\n    LABELS = (\"Unit_ID\", \"Flashing?\")\n    ret = await self._device._write_readline(f\"{self._id}FFP {dur or \"\"}\")\n    ret = ret.split()\n    output_mapping = {\"1\": \"Yes\", \"0\": \"No\"}\n    ret[1] = output_mapping.get(str(ret[1]), ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.change_unit_id","title":"<code>change_unit_id(new_id)</code>  <code>async</code>","text":"<p>Sets the unit ID of the device.</p> Example <p>df = run(dev.change_unit_id, \"B\")</p> Note <p>This changes the ID, but the device stops responding.</p> <p>Parameters:</p> Name Type Description Default <code>new_id</code> <code>str</code> <p>New ID for the device. A-Z accepted</p> required Source code in <code>pyalicat/device.py</code> <pre><code>async def change_unit_id(self, new_id: str) -&gt; None:\n    \"\"\"Sets the unit ID of the device.\n\n    Example:\n        df = run(dev.change_unit_id, \"B\")\n\n    Note:\n        **This changes the ID, but the device stops responding**.\n\n    Args:\n        new_id (str): New ID for the device. A-Z accepted\n    \"\"\"\n    if new_id.upper() not in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n        raise ValueError(\"Invalid ID\")\n    await self._device._write(f\"{self._id}@ {new_id}\")\n    self._id = new_id\n    return\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.config_totalizer","title":"<code>config_totalizer(totalizer=1, flow_stat_val=None, mode=None, limit_mode=None, num=None, dec=None)</code>  <code>async</code>","text":"<p>Enables/Disables and Configures totalizer.</p> Example <p>df = run(dev.config_totalizer, totalizer=1, 1, -1, -1, 10, 0) # For ZTotalizer 1, disable, do not change, do not change, 10 digits, 0 decimals</p> <p>Parameters:</p> Name Type Description Default <code>totalizer</code> <code>int</code> <p>1 or 2, which totalizer used</p> <code>1</code> <code>flow_stat_val</code> <code>str</code> <p>Statistic to measure. Use -1 to not change statistic, use 1 to disable</p> <code>None</code> <code>mode</code> <code>int</code> <p>Manages how to totalizer accumulates flow. -1 to 3</p> <ul> <li>-1 = Do not change</li> <li>0 = add positive flow, ignore negative</li> <li>1 = add negative flow, ignore positive</li> <li>2 = add positive flow, subtract negative</li> <li>3 = add positive flow until flow stops, then reset to 0</li> </ul> <code>None</code> <code>limit_mode</code> <code>int</code> <p>Manages what totalizer does when limit reached. -1 to 3</p> <ul> <li>-1 = Do not change</li> <li>0 = Stop count and leave at max, does not set TOV error</li> <li>1 = Rest to 0, continue count, does not set TOV error</li> <li>2 = Stop count and leave at max, sets TOV error</li> <li>3 = Reset to 0, continue count, sets TOV error</li> </ul> <code>None</code> <code>num</code> <code>int</code> <p>Value 7 to 10. How many digits in totalizer.</p> <code>None</code> <code>dec</code> <code>int</code> <p>0 to 9. How many digits after decimal.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Configuration of totalizer</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def config_totalizer(\n    self,\n    totalizer: int = 1,\n    flow_stat_val: str | None = None,\n    mode: int | None = None,\n    limit_mode: int | None = None,\n    num: int | None = None,\n    dec: int | None = None,\n) -&gt; dict[str, str]:\n    \"\"\"Enables/Disables and Configures totalizer.\n\n    Example:\n        df = run(dev.config_totalizer, totalizer=1, 1, -1, -1, 10, 0) # For ZTotalizer 1, disable, do not change, do not change, 10 digits, 0 decimals\n\n    Args:\n        totalizer (int): 1 or 2, which totalizer used\n        flow_stat_val (str): Statistic to measure. Use -1 to not change statistic, use 1 to disable\n        mode (int): Manages how to totalizer accumulates flow. -1 to 3\n\n            - -1 = Do not change\n            - 0 = add positive flow, ignore negative\n            - 1 = add negative flow, ignore positive\n            - 2 = add positive flow, subtract negative\n            - 3 = add positive flow until flow stops, then reset to 0\n        limit_mode (int): Manages what totalizer does when limit reached. -1 to 3\n\n            - -1 = Do not change\n            - 0 = Stop count and leave at max, does not set TOV error\n            - 1 = Rest to 0, continue count, does not set TOV error\n            - 2 = Stop count and leave at max, sets TOV error\n            - 3 = Reset to 0, continue count, sets TOV error\n        num (int): Value 7 to 10. How many digits in totalizer.\n        dec (int): 0 to 9. How many digits after decimal.\n\n    Returns:\n        dict[str, str]: Configuration of totalizer\n    \"\"\"\n    if self._vers and self._vers &lt; 10.00:\n        raise VersionError(\"Version earlier than 10v00\")\n    LABELS = (\n        \"Unit_ID\",\n        \"Totalizer\",\n        \"Flow_Stat_Val\",\n        \"Mode\",\n        \"Limit_Mode\",\n        \"Num_Digits\",\n        \"Dec_Place\",\n    )\n    if flow_stat_val != \"\":\n        flow_stat_val = statistics.get(flow_stat_val, -1)\n    ret = await self._device._write_readline(\n        f\"{self._id}TC {totalizer} {flow_stat_val or \"\"} {mode or \"\"} {limit_mode or \"\"} {num or \"\"} {dec or \"\"}\"\n    )\n    ret = ret.split()\n    return dict(zip(LABELS, ret))  # Need to convert codes to text\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.configure_data_frame","title":"<code>configure_data_frame(format)</code>  <code>async</code>","text":"<p>Sets data frame's format.</p> Example <p>df = run(dev.configure_data_frame, 0)</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>int</code> <p>What format to set the data frame to.</p> <ul> <li>0 for default: Values have 5 digits, setpoint and totalizer unsigned</li> <li>1 for setpoint and totalizer signed (+ or -)</li> <li>2 for signed setpoint and totalizer, number digits based on resolution</li> </ul> required <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Data Frame in new format</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def configure_data_frame(self, format: int) -&gt; dict[str, str | float]:\n    \"\"\"Sets data frame's format.\n\n    Example:\n        df = run(dev.configure_data_frame, 0)\n\n    Args:\n        format (int): What format to set the data frame to.\n\n            - 0 for default: Values have 5 digits, setpoint and totalizer unsigned\n            - 1 for setpoint and totalizer signed (+ or -)\n            - 2 for signed setpoint and totalizer, number digits based on resolution\n\n    Returns:\n        dict[str, str | float]: Data Frame in new format\n    \"\"\"\n    if self._vers and self._vers &lt; 6.00:\n        raise VersionError(\"Version earlier than 6v00\")\n    if self._df_format is None:\n        await self.get_df_format()\n    ret = await self._device._write_readline(f\"{self._id}FDF {format}\")\n    df = ret.split()\n    for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n        df[index] = float(df[index])\n    return dict(zip(self._df_format, df))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.create_gas_mix","title":"<code>create_gas_mix(name, number, gas_dict={})</code>  <code>async</code>","text":"<p>Sets custom gas mixture.</p> <p>This only works with specific gas codes so far</p> Example <p>df = run(dev.query_gas_mix, \"My Gas\", 255, {\"O2\": 20.0, \"N2\": 80.0})</p> Note <p>Untested</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of custom mixture</p> required <code>number</code> <code>int</code> <p>236 to 255. Gas is saved to this number</p> required <code>gas_dict</code> <code>dict[str, float]</code> <p>Gas name : Percentage of Mixture. Maximum of 5 gases. Percent is Molar             percent up to 2 decimals. Total percentages must sum to 100.00%</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, str | float]</code> <p>Gas number of new mix and percentages and names of each constituent</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def create_gas_mix(\n    self, name: str, number: int, gas_dict: dict[str, float] = {}\n) -&gt; dict[str, str | float]:\n    \"\"\"Sets custom gas mixture.\n\n    This only works with specific gas codes so far\n\n    Example:\n        df = run(dev.query_gas_mix, \"My Gas\", 255, {\"O2\": 20.0, \"N2\": 80.0})\n\n    Note:\n        **Untested**\n\n    Args:\n        name (str): Name of custom mixture\n        number (int): 236 to 255. Gas is saved to this number\n        gas_dict (dict[str, float]): Gas name : Percentage of Mixture. Maximum of 5 gases. Percent is Molar\n                        percent up to 2 decimals. Total percentages must sum to 100.00%\n\n    Returns:\n        dict: Gas number of new mix and percentages and names of each constituent\n    \"\"\"\n    if self._vers and self._vers &lt; 5.00:\n        raise VersionError(\"Version earlier than 5v00\")\n    if len(gas_dict) &gt; 5:\n        raise IndexError(\"Too many input gases\")\n    gas_string = \"\"\n    for x in gas_dict:\n        gas_string += f\" {gas_dict[x]} {gases[x]}\"\n\n    LABELS = (\n        \"Unit_ID\",\n        \"Gas_Num\",\n        \"Gas1_Name\",\n        \"Gas1_Perc\",\n        \"Gas2_Name\",\n        \"Gas2_Perc\",\n        \"Gas3_Name\",\n        \"Gas3_Perc\",\n        \"Gas4_Name\",\n        \"Gas4_Perc\",\n        \"Gas5_Name\",\n        \"Gas5_Perc\",\n    )\n    ret = await self._device._write_readline(\n        f\"{self._id}GM {name} {number} {gas_string}\"\n    )\n    ret = ret.split()\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.data_frame","title":"<code>data_frame()</code>  <code>async</code>","text":"<p>Gets info about current data frame.</p> Example <p>df = run(dev.data_frame)</p> <p>Returns:</p> Name Type Description <code>str</code> <code>list[str]</code> <p>table that outlines data frame format</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def data_frame(self) -&gt; list[str]:\n    \"\"\"Gets info about current data frame.\n\n    Example:\n        df = run(dev.data_frame)\n\n    Returns:\n        str: table that outlines data frame format\n    \"\"\"\n    if self._vers and self._vers &lt; 6.00:\n        raise VersionError(\"Version earlier than 6v00\")\n    ret = await self._device._write_readall(f\"{self._id}??D*\")\n    return ret\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.delete_gas_mix","title":"<code>delete_gas_mix(gasN='')</code>  <code>async</code>","text":"<p>Deletes custom gas mixture.</p> Example <p>df = run(dev.delete_gas_mix, 255)</p> Note <p>Nonfunctional</p> <p>Parameters:</p> Name Type Description Default <code>gasN</code> <code>str</code> <p>Number of gas to delete</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>dict[str, float]: Deleted gas' number</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def delete_gas_mix(self, gasN: str = \"\") -&gt; dict[str, float]:\n    \"\"\"Deletes custom gas mixture.\n\n    Example:\n        df = run(dev.delete_gas_mix, 255)\n\n    Note:\n        **Nonfunctional**\n\n    Args:\n        gasN (str): Number of gas to delete\n\n    Returns:\n        dict[str, float]: Deleted gas' number\n    \"\"\"\n    if self._vers and self._vers &lt; 5.00:\n        raise VersionError(\"Version earlier than 5v00\")\n    LABELS = (\"Unit_ID\", \"Deleted_Gas_Num\")\n    ret = await self._device._write_readline(f\"{self._id}GD {gasN}\")\n    ret = ret.split()\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.firmware_version","title":"<code>firmware_version()</code>  <code>async</code>","text":"<p>Gets the firmware version of the device.</p> Example <p>df = run(dev.firmware_version)</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Current firmware vesion and its date of creation</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def firmware_version(self) -&gt; dict[str, str]:\n    \"\"\"Gets the firmware version of the device.\n\n    Example:\n        df = run(dev.firmware_version)\n\n    Returns:\n        dict[str, str]: Current firmware vesion and its date of creation\n    \"\"\"\n    LABELS = (\"Unit_ID\", \"Vers\", \"Creation_Date\")\n    ret = await self._device._write_readline(f\"{self._id}VE\")\n    ret = ret.split()\n    ret[2] = \" \".join(ret[2:])\n    self._vers = float(ret[1][:-4].replace(\".\", \"\").replace(\"v\", \".\"))\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.flow_press_avg","title":"<code>flow_press_avg(stat_val, avg_time=None)</code>  <code>async</code>","text":"<p>Gets/Set the length of time a statistic is averaged over.</p> Example <p>df = run(dev.flow_press_avg, \"Mass_Flow\")</p> <p>Parameters:</p> Name Type Description Default <code>stat_val</code> <code>str</code> <p>Desired statistic to get average/set time</p> required <code>avg_time</code> <code>int</code> <p>Time in milliseconds over which averages taken. Ranges from 0 to 9999. If 0, the deivce updates every millisecond.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Responds value of queried average and avg time const</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def flow_press_avg(\n    self,\n    stat_val: str | int,\n    avg_time: int | None = None,\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets/Set the length of time a statistic is averaged over.\n\n    Example:\n        df = run(dev.flow_press_avg, \"Mass_Flow\")\n\n    Args:\n        stat_val (str): Desired statistic to get average/set time\n        avg_time (int): Time in milliseconds over which averages taken. Ranges from 0 to 9999. If 0, the deivce updates every millisecond.\n\n    Returns:\n        dict[str, str | float]: Responds value of queried average and avg time const\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Value\", \"Time_Const\")\n    if stat_val.upper() == \"ALL\":\n        stat_val = 1\n    else:\n        stat_val = statistics[stat_val]\n    ret = await self._device._write_readline(\n        f\"{self._id}DCA {stat_val} {avg_time or \"\"}\"\n    )\n    ret = ret.split()\n    ret[1] = int(ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.full_scale_val","title":"<code>full_scale_val(stat_val, unit=None)</code>  <code>async</code>","text":"<p>Gets measurement range of given statistic.</p> Example <p>df = run(dev.full_scale_val, 'Mass_Flow', 'SCCM')</p> <p>Parameters:</p> Name Type Description Default <code>stat_val</code> <code>str</code> <p>Desired statistic to get range</p> required <code>unit</code> <code>str</code> <p>Units of range. Defaults if left blank.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Responds max value of statistic and units</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def full_scale_val(\n    self, stat_val: str | int, unit: str | None = None\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets measurement range of given statistic.\n\n    Example:\n        df = run(dev.full_scale_val, 'Mass_Flow', 'SCCM')\n\n    Args:\n        stat_val (str): Desired statistic to get range\n        unit (str): Units of range. Defaults if left blank.\n\n    Returns:\n        dict[str, str | float]: Responds max value of statistic and units\n    \"\"\"\n    if self._vers and self._vers &lt; 6.00:\n        raise VersionError(\"Version earlier than 6v00\")\n    LABELS = (\"Unit_ID\", \"Max_Value\", \"Unit_Code\", \"Unit_Label\")\n    if unit is None:\n        unit = \"\"\n    ret = await self._device._write_readline(\n        f\"{self._id}FPF {statistics[stat_val]} {units[unit]}\"\n    )\n    ret = ret.split()\n    ret[1] = float(ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.gas","title":"<code>gas(gas=None, save=None)</code>  <code>async</code>","text":"<p>Gets/Sets the gas of the device.</p> Example <p>df = run(dev.gas, 'N2', True)</p> Note <p>Devices with firmware versions 10.05 or greater should use this method</p> <p>Parameters:</p> Name Type Description Default <code>gas</code> <code>str</code> <p>Name of the gas to set on the device.</p> <code>None</code> <code>save</code> <code>bool</code> <p>If true, will apply this gas on powerup.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Reports the gas and its code and names.</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def gas(\n    self, gas: str | None = None, save: bool | None = None\n) -&gt; dict[str, str]:\n    \"\"\"Gets/Sets the gas of the device.\n\n    Example:\n        df = run(dev.gas, 'N2', True)\n\n    Note:\n        Devices with firmware versions 10.05 or greater should use this method\n\n    Args:\n        gas (str): Name of the gas to set on the device.\n        save (bool): If true, will apply this gas on powerup.\n\n    Returns:\n        dict[str, str]: Reports the gas and its code and names.\n    \"\"\"\n    LABELS = (\"Unit_ID\", \"Gas_Code\", \"Gas\", \"Gas_Long\")\n    if gas and self._vers and self._vers &lt; 10.05:\n        warnings.warn(\"Version earlier than 10v05, running Set Gas\")\n        return await self._set_gas(gas)\n    gas = gases.get(gas, \"\")\n    if not gas:\n        save = None\n    if isinstance(save, bool):\n        savestr = \"1\" if save else \"0\"\n    ret = await self._device._write_readline(f\"{self._id}GS {gas or \"\"} {savestr}\")\n    return dict(zip(LABELS, ret.split()))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.gas_list","title":"<code>gas_list()</code>  <code>async</code>","text":"<p>Gets the list of available gases for the device.</p> Example <p>df = run(dev.gas_list)</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: List of all gas codes and their names.</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def gas_list(self) -&gt; dict[str, str]:\n    \"\"\"Gets the list of available gases for the device.\n\n    Example:\n        df = run(dev.gas_list)\n\n    Returns:\n        dict[str, str]: List of all gas codes and their names.\n    \"\"\"\n    ret = {}\n    resp = await self._device._write_readall(f\"{self._id}??G*\")\n    for gas in resp:\n        gas = gas.split()\n        ret[gas[1]] = gas[2]\n    return ret\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.get","title":"<code>get(measurements=['@'])</code>  <code>async</code>","text":"<p>Gets the value of a measurement from the device.</p> <p>Parameters:</p> Name Type Description Default <code>measurements</code> <code>list[str]</code> <p>List of measurements to get. If not specified, gets all measurements in standard dataframe.</p> <code>['@']</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Dictionary of measurements and their values</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def get(self, measurements: list[str] = [\"@\"]) -&gt; dict[str, str | float]:\n    \"\"\"Gets the value of a measurement from the device.\n\n    Args:\n        measurements (list[str]): List of measurements to get. If not specified, gets all measurements in standard dataframe.\n\n    Returns:\n        dict[str, str | float]: Dictionary of measurements and their values\n    \"\"\"\n    resp = {}\n    flag = 0\n    reqs = []\n    # Request\n    if not measurements:\n        measurements = [\"@\"]\n    for meas in measurements:\n        if meas in statistics:\n            reqs.append(meas)\n        elif meas.upper() == \"GAS\":\n            resp.update(await self.gas())\n        elif flag == 0:\n            resp.update(await self.poll())\n            flag = 1\n    i = 0\n    while i * 13 &lt; len(reqs):\n        resp.update(await self.request(reqs[13 * i : 13 + 13 * i]))\n        i += 1\n    return resp\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.get_df_format","title":"<code>get_df_format()</code>  <code>async</code>","text":"<p>Gets the format of the current dataframe format of the device.</p> Example <p>df = run(dev.get_df_format)</p> <p>Returns:</p> Type Description <code>list[list[str]]</code> <p>list[list[str]]: Dataframe format</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def get_df_format(self) -&gt; list[list[str]]:\n    \"\"\"Gets the format of the current dataframe format of the device.\n\n    Example:\n        df = run(dev.get_df_format)\n\n    Returns:\n        list[list[str]]: Dataframe format\n    \"\"\"\n    resp = await self._device._write_readall(f\"{self._id}??D*\")\n    splits = []\n    for match in re.finditer(r\"\\s\", resp[0]):\n        splits.append(match.start())\n    df_table = [\n        [k[i + 1 : j] for i, j in zip(splits, splits[1:] + [None])] for k in resp\n    ]\n    df_format = [\n        i[[idx for idx, s in enumerate(df_table[0]) if \"NAME\" in s][0]].strip()\n        for i in df_table[1:-1]\n    ]\n    df_format = [i.replace(\" \", \"_\") for i in df_format]\n    df_ret = [\n        i[[idx for idx, s in enumerate(df_table[0]) if \"TYPE\" in s][0]].strip()\n        for i in df_table[1:-1]\n    ]\n    df_stand = [i for i in df_format if not (i.startswith(\"*\"))]\n    df_stand_ret = [i for i in df_ret[: len(df_stand)]]\n    self._df_format = df_format\n    self._df_ret = df_ret\n    return [df_stand, df_stand_ret]\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.get_units","title":"<code>get_units(stats)</code>  <code>async</code>","text":"<p>Gets the units of the current dataframe format of the device.</p> <p>Parameters:</p> Name Type Description Default <code>stats</code> <code>list</code> <p>List of statistics to get units for.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>dict[str, str]</code> <p>Units of statistics in measurement</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def get_units(self, stats: list[str]) -&gt; dict[str, str]:\n    \"\"\"Gets the units of the current dataframe format of the device.\n\n    Args:\n        stats (list): List of statistics to get units for.\n\n    Returns:\n        list: Units of statistics in measurement\n    \"\"\"\n    units = []\n    for stat in stats:\n        ret = await self._engineering_units(stat)\n        units.append(ret[\"Unit_Label\"])\n    return dict(zip(stats, units))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.is_model","title":"<code>is_model(model)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Determines if the model is the correct model for the device.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The model to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the model is correct, False otherwise.</p> Source code in <code>pyalicat/device.py</code> <pre><code>@classmethod\n@abstractmethod\ndef is_model(cls, model: str) -&gt; bool:\n    \"\"\"Determines if the model is the correct model for the device.\n\n    Args:\n        model (str): The model to check.\n\n    Returns:\n        bool: True if the model is correct, False otherwise.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.lock_display","title":"<code>lock_display()</code>  <code>async</code>","text":"<p>Disables buttons on front of the device.</p> Example <p>df = run(dev.lock_display)</p> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Data frame with lock status enabled</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def lock_display(self) -&gt; dict[str, str | float]:\n    \"\"\"Disables buttons on front of the device.\n\n    Example:\n        df = run(dev.lock_display)\n\n    Returns:\n        dict[str, str | float]: Data frame with lock status enabled\n    \"\"\"\n    if self._df_format is None:\n        await self.get_df_format()\n    ret = await self._device._write_readline(f\"{self._id}L\")\n    df = ret.split()\n    for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n        df[index] = float(df[index])\n    return dict(zip(self._df_format, df))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.manufacturing_info","title":"<code>manufacturing_info()</code>  <code>async</code>","text":"<p>Gets info about device.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Info on device, model, serial number, manufacturing, calibration, software</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def manufacturing_info(self) -&gt; list[str]:\n    \"\"\"Gets info about device.\n\n    Returns:\n        list[str]: Info on device, model, serial number, manufacturing, calibration, software\n    \"\"\"\n    ret = await self._device._write_readall(f\"{self._id}??M*\")\n    return ret\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.new_device","title":"<code>new_device(port, id='A', **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Creates a new device. Chooses appropriate device based on characteristics.</p> Example <p>dev = run(Device.new_device, '/dev/ttyUSB0')</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The port the device is connected to.</p> required <code>id</code> <code>str</code> <p>The id of the device. Default is \"A\".</p> <code>'A'</code> <code>**kwargs</code> <code>Any</code> <p>Any</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Device</code> <code>Self</code> <p>The new device.</p> Source code in <code>pyalicat/device.py</code> <pre><code>@classmethod\nasync def new_device(cls, port: str, id: str = \"A\", **kwargs: Any) -&gt; Self:\n    \"\"\"Creates a new device. Chooses appropriate device based on characteristics.\n\n    Example:\n        dev = run(Device.new_device, '/dev/ttyUSB0')\n\n    Args:\n        port (str): The port the device is connected to.\n        id (str): The id of the device. Default is \"A\".\n        **kwargs: Any\n\n    Returns:\n        Device: The new device.\n    \"\"\"\n    if port.startswith(\"/dev/\"):\n        device = SerialDevice(port, **kwargs)\n    dev_info_ret = await device._write_readall(f\"{id}??M*\")\n    if not dev_info_ret:\n        raise ValueError(\"No device found on port\")\n    INFO_KEYS = (\n        \"manufacturer\",\n        \"website\",\n        \"phone\",\n        \"website\",\n        \"model\",\n        \"serial\",\n        \"manufactured\",\n        \"calibrated\",\n        \"calibrated_by\",\n        \"software\",\n    )\n    try:\n        dev_info = dict(\n            zip(\n                INFO_KEYS,\n                [i[re.search(r\"M\\d\\d\", i).end() + 1 :] for i in dev_info_ret],\n            )\n        )\n    except AttributeError:\n        raise ValueError(\"No device found on port\")\n    for cls in all_subclasses(Device):\n        if cls.is_model(dev_info[\"model\"]):\n            new_cls = cls(device, dev_info, id, **kwargs)\n            await new_cls.get_df_format()\n            return new_cls\n    raise ValueError(f\"Unknown device model: {dev_info['model']}\")\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.poll","title":"<code>poll()</code>  <code>async</code>","text":"<p>Gets the current measurements of the device in defined data frame format.</p> Example <p>df = run(dev.poll)</p> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: The current measurements of the device from defined data frame format.</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def poll(self) -&gt; dict[str, str | float]:\n    \"\"\"Gets the current measurements of the device in defined data frame format.\n\n    Example:\n        df = run(dev.poll)\n\n    Returns:\n        dict[str, str | float]: The current measurements of the device from defined data frame format.\n    \"\"\"\n    # Gets the format of the dataframe if it is not already known\n    if self._df_format is None:\n        await self.get_df_format()\n    ret = await self._device._write_readline(self._id)\n    df = ret.split()\n    for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n        df[index] = float(df[index])\n    return dict(zip(self._df_format, df))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.power_up_tare","title":"<code>power_up_tare(enable=None)</code>  <code>async</code>","text":"<p>Gets/Sets if device tares on power-up.</p> Example <p>df = run(dev.power_up_tare, False)</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>If Enabled, 0.25 second after sensors stable. Close loop delay, valves stay closed</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: If tare is enabled</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def power_up_tare(self, enable: bool | None = None) -&gt; dict[str, str]:\n    \"\"\"Gets/Sets if device tares on power-up.\n\n    Example:\n        df = run(dev.power_up_tare, False)\n\n    Args:\n        enable (bool): If Enabled, 0.25 second after sensors stable. Close loop delay, valves stay closed\n\n    Returns:\n        dict[str, str]: If tare is enabled\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Power-Up_Tare\")\n    enable_str = \"1\" if enable else \"0\" if enable is not None else \"\"\n    ret = await self._device._write_readline(f\"{self._id}ZCP {enable_str}\")\n    ret = ret.split()\n    output_mapping = {\"1\": \"Enabled\", \"0\": \"Disabled\"}\n    ret[1] = output_mapping.get(str(ret[1]), ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.query_gas_mix","title":"<code>query_gas_mix(gasN)</code>  <code>async</code>","text":"<p>Gets percentages of gases in mixture.</p> Example <p>df = run(dev.query_gas_mix, 255)</p> <p>Parameters:</p> Name Type Description Default <code>gasN</code> <code>int</code> <p>Number of the custom gas to analyze</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Gas numbers and their percentages in mixture</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def query_gas_mix(self, gasN: int) -&gt; dict[str, str]:\n    \"\"\"Gets percentages of gases in mixture.\n\n    Example:\n        df = run(dev.query_gas_mix, 255)\n\n    Args:\n       gasN (int): Number of the custom gas to analyze\n\n    Returns:\n        dict[str, str]: Gas numbers and their percentages in mixture\n    \"\"\"\n    if self._vers and self._vers &lt; 9.00:\n        raise VersionError(\"Version earlier than 9v00\")\n    LABELS = (\n        \"Unit_ID\",\n        \"Gas_Num\",\n        \"Gas1_Name\",\n        \"Gas1_Perc\",\n        \"Gas2_Name\",\n        \"Gas2_Perc\",\n        \"Gas3_Name\",\n        \"Gas3_Perc\",\n        \"Gas4_Name\",\n        \"Gas4_Perc\",\n        \"Gas5_Name\",\n        \"Gas5_Perc\",\n    )\n    ret = await self._device._write_readall(f\"{self._id}GC {gasN}\")\n    ret = ret[0].replace(\"=\", \" \").split()\n    for i in range(len(ret)):\n        if \"Name\" in LABELS[i]:\n            ret[i] = next(\n                (code for code, value in gases.items() if value == int(ret[i])),\n                ret[i],\n            )\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.remote_tare","title":"<code>remote_tare(actions=None)</code>  <code>async</code>","text":"<p>Gets/Sets the remote tare value.</p> Example <p>df = run(dev.remote_tare, [\"Primary Press\", \"Secondary Press\"])</p> Note <p>This usually only works on meters and gauges. Not all devices support this.</p> Note <p>Untested: Sets the remote tare effect.</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>list[str]</code> <p>Actions to perform</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Total value of active actions</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def remote_tare(\n    self, actions: list[str] | None = None\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets/Sets the remote tare value.\n\n    Example:\n        df = run(dev.remote_tare, [\"Primary Press\", \"Secondary Press\"])\n\n    Note:\n        This usually only works on meters and gauges. Not all devices support this.\n\n    Note:\n        **Untested: Sets the remote tare effect.**\n\n    Args:\n        actions (list[str]): Actions to perform\n\n    Returns:\n        dict[str, str | float]: Total value of active actions\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Active_Actions_Total\")\n    if actions is None:\n        actions = []\n    action_dict = {\n        \"Primary_Press\": 1,\n        \"Secondary_Press\": 2,\n        \"Flow\": 4,\n        \"Reset_Totalizer_1\": 8,\n        \"Reset_Totalizer_2\": 16,\n    }\n    act_tot: int | None = sum([action_dict.get(act, 0) for act in actions])\n    if not actions:\n        act_tot = None\n    ret = await self._device._write_readline(f\"{self._id}ASRCA {act_tot or \"\"}\")\n    ret = ret.split()\n    ret[1] = int(ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.request","title":"<code>request(stats=None, time=1)</code>  <code>async</code>","text":"<p>Gets requested measurements averaged over specified time.</p> Example <p>df = run(dev.request, ['Mass_Flow', 'Abs_Press'], 1000)</p> <p>Parameters:</p> Name Type Description Default <code>stats</code> <code>list[str]</code> <p>Names of the statistics to get. Maximum of 13 statistics in one call.</p> <code>None</code> <code>time</code> <code>int</code> <p>The time to average over in milliseconds. Default is 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: The requested statistics.</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def request(\n    self, stats: list[str] | None = None, time: int = 1\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets requested measurements averaged over specified time.\n\n    Example:\n        df = run(dev.request, ['Mass_Flow', 'Abs_Press'], 1000)\n\n    Args:\n        stats (list[str]): Names of the statistics to get. Maximum of 13 statistics in one call.\n        time (int): The time to average over in milliseconds. Default is 1.\n\n    Returns:\n        dict[str, str | float]: The requested statistics.\n    \"\"\"\n    if stats is None:\n        stats = []\n    if len(stats) &gt; 13:\n        raise IndexError(\"Too many statistics requested\")\n        # stats = stats[:13]\n    ret = await self._device._write_readline(\n        f\"{self._id}DV {time} {' '.join(str(statistics[stat]) for stat in stats)}\"  # add a parameter for time out here\n    )\n    ret = ret.split()\n    for idx in range(len(ret)):\n        try:\n            ret[idx] = float(ret[idx])\n        except ValueError:\n            pass\n        if ret[idx] == \"--\":\n            ret[idx] = None\n    return dict(zip(stats, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.reset_totalizer","title":"<code>reset_totalizer(totalizer=1)</code>  <code>async</code>","text":"<p>Returns totalizer count to zero and restarts timer.</p> Example <p>df = run(dev.reset_totalizer, totalizer=1)</p> Note <p>Untested.</p> <p>Parameters:</p> Name Type Description Default <code>totalizer</code> <code>int</code> <p>Which totalizer to reset: 1 or 2</p> <code>1</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Dataframe with totalizer set to zero.</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def reset_totalizer(self, totalizer: int = 1) -&gt; dict[str, str | float]:\n    \"\"\"Returns totalizer count to zero and restarts timer.\n\n    Example:\n        df = run(dev.reset_totalizer, totalizer=1)\n\n    Note:\n        **Untested.**\n\n    Args:\n        totalizer (int): Which totalizer to reset: 1 or 2\n\n    Returns:\n        dict[str, str | float]: Dataframe with totalizer set to zero.\n    \"\"\"\n    if self._vers and self._vers &lt; 8.00:\n        raise VersionError(\"Version earlier than 8v00\")\n    if self._df_format is None:\n        await self.get_df_format()\n    ret = await self._device._write_readline(f\"{self._id}T {totalizer}\")\n    df = ret.split()\n    for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n        df[index] = float(df[index])\n    return dict(zip(self._df_format, df))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.reset_totalizer_peak","title":"<code>reset_totalizer_peak(totalizer=1)</code>  <code>async</code>","text":"<p>Resets peak flow rate that has been measured since last reset.</p> Example <p>df = run(dev.reset_totalizer_peak, totalizer=1)</p> Note <p>Untested.</p> <p>Parameters:</p> Name Type Description Default <code>totalizer</code> <code>int</code> <p>Which totalizer to reset: 1 or 2</p> <code>1</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Data frame</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def reset_totalizer_peak(self, totalizer: int = 1) -&gt; dict[str, str | float]:\n    \"\"\"Resets peak flow rate that has been measured since last reset.\n\n    Example:\n        df = run(dev.reset_totalizer_peak, totalizer=1)\n\n    Note:\n        **Untested.**\n\n    Args:\n        totalizer (int): Which totalizer to reset: 1 or 2\n\n    Returns:\n        dict[str, str | float]: Data frame\n    \"\"\"\n    if self._vers and self._vers &lt; 8.00:\n        raise VersionError(\"Version earlier than 8v00\")\n    if self._df_format is None:\n        await self.get_df_format()\n    ret = await self._device._write_readline(f\"{self._id}TP {totalizer}\")\n    df = ret.split()\n    for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n        df[index] = float(df[index])\n    return dict(zip(self._df_format, df))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.restore_factory_settings","title":"<code>restore_factory_settings()</code>  <code>async</code>","text":"<p>Restores factory settings of the device.</p> <p>Removes any calibrations.</p> Example <p>df = run(dev.restore_factory_settings)</p> Note <p>Untested.</p> <p>Returns:</p> Type Description <code>str</code> <p>Confirmation of restoration</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def restore_factory_settings(self) -&gt; str:\n    \"\"\"Restores factory settings of the device.\n\n    Removes any calibrations.\n\n    Example:\n        df = run(dev.restore_factory_settings)\n\n    Note:\n        **Untested.**\n\n    Returns:\n        Confirmation of restoration\n    \"\"\"\n    if self._vers and self._vers &lt; 7.00:\n        raise VersionError(\"Version earlier than 7v00\")\n    ret = await self._device._write_readline(f\"{self._id}FACTORY RESTORE ALL\")\n    return ret\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.save_totalizer","title":"<code>save_totalizer(enable=None)</code>  <code>async</code>","text":"<p>Enables/disables saving totalizer values at regular intervals.</p> <p>If enabled, restore last saved totalizer on power-up.</p> Example <p>df = run(dev.save_totalizer, enable=True)</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to enable or disable saving totalizer values on startup</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Says if totalizer is enabled or disabled</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def save_totalizer(self, enable: bool | None = None) -&gt; dict[str, str]:\n    \"\"\"Enables/disables saving totalizer values at regular intervals.\n\n    If enabled, restore last saved totalizer on power-up.\n\n    Example:\n        df = run(dev.save_totalizer, enable=True)\n\n    Args:\n       enable (bool): Whether to enable or disable saving totalizer values on startup\n\n    Returns:\n        dict[str, str]: Says if totalizer is enabled or disabled\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Saving\")\n    enable_str = \"1\" if enable else \"0\" if enable is not None else \"\"\n    ret = await self._device._write_readline(f\"{self._id}TCR {enable_str}\")\n    ret = ret.split()\n    output_mapping = {\"1\": \"Enabled\", \"0\": \"Disabled\"}\n    ret[1] = output_mapping.get(str(ret[1]), ret[1])\n    return dict(zip(LABELS, ret))  # Need to convert codes to text\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.set","title":"<code>set(comm)</code>  <code>async</code>","text":"<p>Sets the values of measurements for the device.</p> <p>Parameters:</p> Name Type Description Default <code>comm</code> <code>dict[str, str]</code> <p>Dictionary with command to set as key, parameters as values. Use a list for multiple parameters</p> required <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str: response of setting function</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def set(self, comm: dict[str, list[str | float]]) -&gt; dict[str, str | float]:\n    \"\"\"Sets the values of measurements for the device.\n\n    Args:\n        comm (dict[str, str]): Dictionary with command to set as key, parameters as values. Use a list for multiple parameters\n\n    Returns:\n        dict[str, str: response of setting function\n    \"\"\"\n    resp: dict[str, str | float] = {}\n    for meas in list(comm.keys()):\n        upper_meas = str(meas).upper()\n        # Set gas - Param1 = gas: str = \"\", Param2 = save: bool = \"\"\n        if upper_meas == \"GAS\":\n            resp.update(await self.gas(str(comm[meas][0]), str(comm[meas][1])))\n    return resp\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.set_units","title":"<code>set_units(stats)</code>  <code>async</code>","text":"<p>Sets the units of the current dataframe format of the device.</p> <p>Parameters:</p> Name Type Description Default <code>stats</code> <code>dict[str, str]</code> <p>Dictionary of statistics and their units</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Units of statistics in measurement</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def set_units(self, stats: dict[str, str]) -&gt; dict[str, str]:\n    \"\"\"Sets the units of the current dataframe format of the device.\n\n    Args:\n        stats (dict[str, str]): Dictionary of statistics and their units\n\n    Returns:\n        dict[str, str]: Units of statistics in measurement\n    \"\"\"\n    for stat in stats:\n        ret = await self._engineering_units(stat, stats[stat])\n        stats[stat] = ret[\"Unit_Label\"]\n    return stats\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.start_stream","title":"<code>start_stream()</code>  <code>async</code>","text":"<p>Starts streaming data from device.</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def start_stream(self) -&gt; None:\n    \"\"\"Starts streaming data from device.\"\"\"\n    await self._device._write(f\"{self._id}@ @\")\n    return\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.stop_stream","title":"<code>stop_stream(new_id=None)</code>  <code>async</code>","text":"<p>Stops streaming data from device.</p> Example <p>df = run(dev.stop_stream, 'B')</p> <p>Parameters:</p> Name Type Description Default <code>new_id</code> <code>str</code> <p>New device ID if desired. Will default to current ID if not given.</p> <code>None</code> Source code in <code>pyalicat/device.py</code> <pre><code>async def stop_stream(self, new_id: str | None = None) -&gt; None:\n    \"\"\"Stops streaming data from device.\n\n    Example:\n        df = run(dev.stop_stream, 'B')\n\n    Args:\n        new_id (str): New device ID if desired. Will default to current ID if not given.\n    \"\"\"\n    if new_id is None:\n        new_id = self._id\n    await self._device._write(f\"@@ {new_id}\")\n    self.id = new_id\n    return\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.stp_press","title":"<code>stp_press(stp='S', unit=None, press=None)</code>  <code>async</code>","text":"<p>Gets/Sets standard or normal pressure reference point.</p> <p>To get Normal pressure reference point, set stp to N.</p> Example <p>df = run(dev.stp_press, 'S', 'PSIA', 14.69595)</p> <p>Parameters:</p> Name Type Description Default <code>stp</code> <code>str</code> <p>S for standard pressure, N for normal</p> <code>'S'</code> <code>unit</code> <code>str</code> <p>Pressure units</p> <code>None</code> <code>press</code> <code>float</code> <p>Numeric value of new desired pressure reference point</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Current pressure reference point and units</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def stp_press(\n    self, stp: str = \"S\", unit: str | None = None, press: float | None = None\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets/Sets standard or normal pressure reference point.\n\n    To get Normal pressure reference point, set stp to N.\n\n    Example:\n        df = run(dev.stp_press, 'S', 'PSIA', 14.69595)\n\n    Args:\n        stp (str): S for standard pressure, N for normal\n        unit (str): Pressure units\n        press (float): Numeric value of new desired pressure reference point\n\n    Returns:\n        dict[str, str | float]: Current pressure reference point and units\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Curr_Press_Ref\", \"Unit_Code\", \"Unit_Label\")\n    if stp.upper() == \"NTP\":\n        stp = \"N\"\n    if stp.upper() != \"N\":\n        stp = \"S\"\n    if unit is None:\n        unit = \"\"\n    ret = await self._device._write_readline(\n        f\"{self._id}DCFRP {stp.upper()} {str(units[unit])} {press or \"\"}\"\n    )\n    ret = ret.split()\n    ret[1] = float(ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.stp_temp","title":"<code>stp_temp(stp='S', unit=None, temp=None)</code>  <code>async</code>","text":"<p>Gets/Sets standard or normal temperature reference point.</p> <p>To get Normal temperature reference point, set stp to N.</p> Example <p>df = run(dev.stp_temp, 'S', 'C', 25.0)</p> <p>Parameters:</p> Name Type Description Default <code>stp</code> <code>str</code> <p>S for standard temperature, N for normal</p> <code>'S'</code> <code>unit</code> <code>str</code> <p>Temperature units</p> <code>None</code> <code>temp</code> <code>float</code> <p>Numeric value of new desired temperature reference point</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Current temperature reference point and units</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def stp_temp(\n    self, stp: str = \"S\", unit: str | None = None, temp: float | None = None\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets/Sets standard or normal temperature reference point.\n\n    To get Normal temperature reference point, set stp to N.\n\n    Example:\n        df = run(dev.stp_temp, 'S', 'C', 25.0)\n\n    Args:\n        stp (str): S for standard temperature, N for normal\n        unit (str): Temperature units\n        temp (float): Numeric value of new desired temperature reference point\n\n    Returns:\n        dict[str, str | float]: Current temperature reference point and units\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Curr_Temp_Ref\", \"Unit_Code\", \"Unit_Label\")\n    if stp.upper() == \"NTP\":\n        stp = \"N\"\n    if stp.upper() != \"N\":\n        stp = \"S\"\n    if unit is None:\n        unit = \"\"\n    ret = await self._device._write_readline(\n        f\"{self._id}DCFRT {stp.upper()} {str(units[unit])} {temp or \"\"}\"\n    )\n    ret = ret.split()\n    ret[1] = float(ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.streaming_rate","title":"<code>streaming_rate(interval=None)</code>  <code>async</code>","text":"<p>Gets/Sets the streaming rate of the device.</p> Example <p>df = run(dev.streaming_rate, 50)</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>int</code> <p>Streaming rate in milliseconds between data frames</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Interval of streaming rate</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def streaming_rate(\n    self, interval: int | None = None\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets/Sets the streaming rate of the device.\n\n    Example:\n        df = run(dev.streaming_rate, 50)\n\n    Args:\n        interval (int): Streaming rate in milliseconds between data frames\n\n    Returns:\n        dict[str, str | float]: Interval of streaming rate\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Interval_(ms)\")\n    ret = await self._device._write_readline(f\"{self._id}NCS {interval or \"\"}\")\n    ret = ret.split()\n    ret[1] = int(ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.tare_abs_P","title":"<code>tare_abs_P()</code>  <code>async</code>","text":"<p>Tares the absolute pressure of the device, zeros out the absolute pressure reference point.</p> <p>Should only be used when no flow and line is not pressurized.</p> Example <p>df = run(dev.tare_abs_P)</p> Note <p>Untested.</p> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Dataframe with zero absolute pressure</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def tare_abs_P(self) -&gt; dict[str, str | float]:\n    \"\"\"Tares the absolute pressure of the device, zeros out the absolute pressure reference point.\n\n    Should only be used when no flow and line is not pressurized.\n\n    Example:\n        df = run(dev.tare_abs_P)\n\n    Note:\n        **Untested.**\n\n    Returns:\n        dict[str, str | float]: Dataframe with zero absolute pressure\n    \"\"\"\n    # Gets the format of the dataframe if it is not already known\n    if self._df_format is None:\n        await self.get_df_format()\n    ret = await self._device._write_readline(f\"{self._id}PC\")\n    df = ret.split()\n    for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n        df[index] = float(df[index])\n    return dict(zip(self._df_format, df))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.tare_flow","title":"<code>tare_flow()</code>  <code>async</code>","text":"<p>Creates a no-flow reference point.</p> <p>Should only be used when no flow and at operation pressure.</p> Example <p>df = run(dev.tare_flow)</p> Note <p>Untested.</p> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Dataframe with zero flow.</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def tare_flow(self) -&gt; dict[str, str | float]:\n    \"\"\"Creates a no-flow reference point.\n\n    Should only be used when no flow and at operation pressure.\n\n    Example:\n        df = run(dev.tare_flow)\n\n    Note:\n        **Untested.**\n\n    Returns:\n        dict[str, str | float]: Dataframe with zero flow.\n    \"\"\"\n    # Gets the format of the dataframe if it is not already known\n    if self._df_format is None:\n        await self.get_df_format()\n    ret = await self._device._write_readline(f\"{self._id}V\")\n    df = ret.split()\n    for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n        df[index] = float(df[index])\n    return dict(zip(self._df_format, df))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.tare_gauge_P","title":"<code>tare_gauge_P()</code>  <code>async</code>","text":"<p>Tares the gauge pressure of the device or differential pressure reference point.</p> <p>Should only be used when no flow and open to atmosphere.</p> Example <p>df = run(dev.tare_guage_P)</p> Note <p>Untested.</p> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Dataframe with zero guage pressure.</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def tare_gauge_P(self) -&gt; dict[str, str | float]:\n    \"\"\"Tares the gauge pressure of the device or differential pressure reference point.\n\n    Should only be used when no flow and open to atmosphere.\n\n    Example:\n        df = run(dev.tare_guage_P)\n\n    Note:\n        **Untested.**\n\n    Returns:\n        dict[str, str | float]: Dataframe with zero guage pressure.\n    \"\"\"\n    # Gets the format of the dataframe if it is not already known\n    if self._df_format is None:\n        await self.get_df_format()\n    ret = await self._device._write_readline(f\"{self._id}P\")\n    df = ret.split()\n    for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n        df[index] = float(df[index])\n    return dict(zip(self._df_format, df))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.unlock_display","title":"<code>unlock_display()</code>  <code>async</code>","text":"<p>Enables buttons on front of the device.</p> Example <p>df = run(dev.unlock_display)</p> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Data frame with LCK disabled</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def unlock_display(self) -&gt; dict[str, str | float]:\n    \"\"\"Enables buttons on front of the device.\n\n    Example:\n        df = run(dev.unlock_display)\n\n    Returns:\n        dict[str, str | float]: Data frame with LCK disabled\n    \"\"\"\n    # Gets the format of the dataframe if it is not already known\n    if self._df_format is None:\n        await self.get_df_format()\n    ret = await self._device._write_readline(f\"{self._id}U\")\n    df = ret.split()\n    for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n        df[index] = float(df[index])\n    return dict(zip(self._df_format, df))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.user_data","title":"<code>user_data(slot, val=None)</code>  <code>async</code>","text":"<p>Gets/Sets user data in slot.</p> <p>Gets the user data from the string is slot. Sets the user data in slot to val.</p> Example <p>df = run(dev.user_data, 0, \"New Value\")</p> <p>Parameters:</p> Name Type Description Default <code>slot</code> <code>int</code> <p>Slot number, 0 to 3</p> required <code>val</code> <code>str</code> <p>32-char ASCII string. Must be encoded.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Value in called slot (either new or read)</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def user_data(self, slot: int, val: str | None = None) -&gt; dict[str, str]:\n    \"\"\"Gets/Sets user data in slot.\n\n    Gets the user data from the string is slot.\n    Sets the user data in slot to val.\n\n    Example:\n        df = run(dev.user_data, 0, \"New Value\")\n\n    Args:\n        slot (int): Slot number, 0 to 3\n        val (str): 32-char ASCII string. Must be encoded.\n\n    Returns:\n        dict[str, str]: Value in called slot (either new or read)\n    \"\"\"\n    if self._vers and self._vers &lt; 8.24:\n        raise VersionError(\"Version earlier than 8v24\")\n    if val is None:\n        LABELS = (\"Unit_ID\", \"Curr_Value\")\n    else:\n        LABELS = (\"Unit_ID\", \"New_Value\")\n    ret = await self._device._write_readline(f\"{self._id}UD {slot} {val or \"\"}\")\n    ret = ret.split()\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.Device.zero_band","title":"<code>zero_band(zb=None)</code>  <code>async</code>","text":"<p>Gets/Sets the zero band of the device.</p> Example <p>df = run(dev.zero_band, 0.0)</p> <p>Parameters:</p> Name Type Description Default <code>zb</code> <code>float</code> <p>% of full-scale readings process must exceed before device reports readings</p> <ul> <li>0 to 6.38 range</li> <li>0 to disable</li> </ul> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Returns current zero band as percent of full scale</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def zero_band(self, zb: float | int | None = None) -&gt; dict[str, str | float]:\n    \"\"\"Gets/Sets the zero band of the device.\n\n    Example:\n        df = run(dev.zero_band, 0.0)\n\n    Args:\n        zb (float): % of full-scale readings process must exceed before device reports readings\n\n            - 0 to 6.38 range\n            - 0 to disable\n\n    Returns:\n        dict[str, str | float]: Returns current zero band as percent of full scale\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Zero_Band_(%)\")\n    zb_str = f\"0 {zb:.2f}\" if zb is not None else \"\"\n    ret = await self._device._write_readline(f\"{self._id}DCZ {zb_str}\")\n    ret = ret.split()\n    ret.pop(1)\n    ret[1] = float(ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController","title":"<code>FlowController</code>","text":"<p>               Bases: <code>FlowMeter</code></p> <p>A class used to represent a flow controller. Extends flow meter.</p> Source code in <code>pyalicat/device.py</code> <pre><code>class FlowController(FlowMeter):\n    \"\"\"A class used to represent a flow controller. Extends flow meter.\"\"\"\n\n    @classmethod\n    def is_model(cls, model: str) -&gt; bool:\n        \"\"\"Checks if the flow meter is of a certain model.\n\n        Args:\n            model (str): Model of flow meter.\n\n        Returns:\n            bool: True if model matches.\n        \"\"\"\n        models = [\" MC-\", \" MCS-\", \" MCQ-\", \" MCW-\"]\n        return any([bool(re.search(i, model)) for i in models])\n\n    def __init__(\n        self, device: SerialDevice, dev_info: dict, id: str = \"A\", **kwargs: Any\n    ) -&gt; None:\n        \"\"\"Connects to the flow controller.\n\n        Args:\n            device (Device): The Device object.\n            dev_info (dict): The device information dictionary.\n            id (str, optional): Unit ID of Alicat flow controller. Defaults to \"A\".\n            **kwargs (Any): Additional keyword arguments.\n        \"\"\"\n        super().__init__(device, dev_info, id, **kwargs)\n\n    async def setpoint(\n        self, value: float | None = None, unit: str | None = None\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets/Sets the setpoint of the device.\n\n        Example:\n            df = run(dev.setpoint, 50, \"SCCM\")\n\n        Note:\n            Devices with firmware versions 9.00 or greater should use this method\n\n        Args:\n            value (float): Desired setpoint value for the controller. Set to 0 to close valve.\n            unit (str): Set setpoint units.\n\n        Returns:\n            dict[str, str | float]: Reports setpoint with units\n        \"\"\"\n        if self._vers and self._vers &lt; 9.00:\n            if value is None:\n                raise ValueError(\"Query setpoint is not supported for this software\")\n            else:\n                warnings.warn(\"Version earlier than 9v00, running Change Setpoint\")\n                return await self.change_setpoint(value)\n        LABELS = (\n            \"Unit_ID\",\n            \"Curr_Setpt\",\n            \"Requested_Setpt\",\n            \"Unit_Code\",\n            \"Unit_Label\",\n        )\n        ret = await self._device._write_readline(\n            f\"{self._id}LS {value or \"\"} {units[unit]}\"\n        )\n        if ret == \"?\":\n            raise ValueError(\"Invalid setpoint value\")\n        ret = ret.split()\n        ret[1], ret[2] = float(ret[1]), float(ret[2])\n        return dict(zip(LABELS, ret))\n\n    async def _change_setpoint(\n        self, value: float | None = None\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Changes the setpoint of the device.\n\n        Example:\n            df = run(dev._change_setpoint, 50)\n\n        Note:\n            Devices with firmware versions less than 9.00 should use this method\n\n        Args:\n            value (float): Desired setpoint value for the controller. Set to 0 to close valve.\n\n        Returns:\n            dict[str, str | float]: Dataframe with new setpoint\n        \"\"\"\n        if self._vers and self._vers &lt; 4.33:\n            raise VersionError(\"Version earlier than 4v33\")\n        if self._vers and self._vers &gt;= 9.00:\n            warnings.warn(\"Version later than 9v00, running Query/Change Setpoint\")\n            return await self.setpoint(value)\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(f\"{self._id}S {value}\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def batch(\n        self, totalizer: int = 1, batch_vol: int | None = None, unit: str | None = None\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Directs controller to flow a set amount then close the valve.\n\n        Example:\n            df = run(dev.batch, 1, 100, \"SCCM\")\n\n        Note:\n            **Untested.**\n\n        Args:\n            totalizer (int): Totalizer (1 or 2) to use/query. Defaults to 1.\n            batch_vol (int): Size of desired batch flow. Set to 0 to disable batch.\n            unit (str): Volume units for flow.\n\n        Returns:\n            dict[str, str | float]: Reports totalizer, batch size, units.\n        \"\"\"\n        if self._vers and self._vers &lt; 10.00:\n            raise VersionError(\"Version earlier than 10v00\")\n        LABELS = (\"Unit_ID\", \"Totalizer\", \"Batch_Size\", \"Unit_Code\", \"Unit_Label\")\n        unit_str = units[unit] if unit else \"\"\n        ret = await self._device._write_readline(\n            f\"{self._id}TB {totalizer} {batch_vol or \"\"} {unit_str}\"\n        )\n        return dict(zip(LABELS, ret.split()))\n\n    async def deadband_limit(\n        self, save: bool | None = None, limit: float | None = None\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets/Sets the range the controller allows for drift around setpoint.\n\n        Example:\n            df = run(dev.deadband_mode, False, 0)\n\n        Args:\n            save (bool): Whether to save the deadband limit on startup\n            limit (float): Value of deadband limit\n\n        Returns:\n            dict[str, str | float]: Reports deadband with units\n        \"\"\"\n        LABELS = (\"Unit_ID\", \"Deadband\", \"Unit_Code\", \"Unit_Label\")\n        save_str = \"1\" if save else \"0\" if save is not None else \"\"\n        ret = await self._device._write_readline(\n            f\"{self._id}LCDB {save_str} {limit or \"\"}\"\n        )\n        ret = ret.split()\n        ret[1] = float(ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def deadband_mode(self, mode: str | None = None) -&gt; dict[str, str]:\n        \"\"\"Gets/Sets the reaction the controller has for values around setpoint.\n\n        Example:\n            df = run(dev.deadband_mode, \"Close\")\n\n        Args:\n            mode (str): \"Hold\" or \"Current\" holds valve and current positions until outside the limits. \"Close\" closes valve until outside the limits.\n\n        Returns:\n            dict[str, str]: Reports mode\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Mode\")\n        if mode:\n            mode = (\n                \"1\"\n                if mode.upper() in [\"HOLD\", \"CURRENT\"]\n                else \"2\"\n                if mode.upper() in [\"CLOSE\"]\n                else mode\n            )\n        ret = await self._device._write_readline(f\"{self._id}LCDM {mode or \"\"}\")\n        ret = ret.split()\n        output_mapping = {\"1\": \"Hold valve at current\", \"2\": \"Close valve\"}\n        ret[1] = output_mapping.get(str(ret[1]), ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def loop_control_alg(self, algo: str | None = None) -&gt; dict[str, str]:\n        \"\"\"Gets/Sets the control algorithm the controller uses.\n\n        - algorithm 1 = PD/PDF\n        - algorithm 2 = PD2I\n\n        Example:\n            df = run(dev.loop_control_alg, \"PD/PDF\")\n\n        Args:\n            algo (str): Algorithm used for loop control. \"PD\", \"PDF\", \"PD/PDF\", \"PD2I\"\n\n        Returns:\n            dict[str, str]: Reports algorithm\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Algorithm\")\n        if algo:\n            algo = (\n                \"2\"\n                if algo.upper() in [\"PD2I\"]\n                else \"1\"\n                if algo.upper() in [\"PD\", \"PDF\", \"PD/PDF\"]\n                else algo\n            )\n        ret = await self._device._write_readline(f\"{self._id}LCA {algo or \"\"}\")\n        ret = ret.split()\n        algorithm_mapping = {\"1\": \"PD/PDF\", \"2\": \"PD2I\"}\n        ret[1] = algorithm_mapping.get(str(ret[1]), ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def loop_control_var(self, var: str) -&gt; dict[str, str]:\n        \"\"\"Sets the statistic the setpoint controls.\n\n        Example:\n            df = run(dev.loop_control_var, 'Mass_Flow_Setpt')\n\n        Args:\n            var (str): Desired statistic\n\n        Returns:\n            dict[str, str]: Reports new loop variable\n        \"\"\"\n        if self._vers and self._vers &lt; 9.00:\n            raise VersionError(\"Version earlier than 9v00\")\n        LABELS = (\"Unit_ID\", \"Loop_Var_Val\")\n        # If the user did not specify setpoint, assume Setpt\n        if var and var[-6:] != \"_Setpt\":\n            var += \"_Setpt\"\n        ret = await self._device._write_readline(f\"{self._id}LV {statistics[var]}\")\n        ret = ret.split()\n        ret[1] = next(\n            (code for code, value in statistics.items() if value == int(ret[1])), ret[1]\n        )\n        return dict(zip(LABELS, ret))\n\n    async def loop_control_range(\n        self,\n        var: str | None = None,\n        unit: str | None = None,\n        min: float | None = None,\n        max: float | None = None,\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets/Sets the control range of the statistic the setpoint controls.\n\n        Example:\n            df = run(dev.loop_control_gains, 'Mass_Flow_Setpt', 'SCCM', 0, 500)\n\n        Args:\n            var (str): Desired statistic to be queried/modified\n            unit (str): Units of var\n            min (float): Min allowable setpoint\n            max (float): Max allowable setpoint\n\n        Returns:\n            dict[str, str | float]: Reports loop variable, units, min, and max\n        \"\"\"\n        if self._vers and self._vers &lt; 9.00:\n            raise VersionError(\"Version earlier than 9v00\")\n        LABELS = (\"Unit_ID\", \"Loop_Var\", \"Min\", \"Max\", \"Unit_Code\", \"Unit_Label\")\n        if self._vers and self._vers &lt; 10.05:\n            warnings.warn(\"Version earlier than 10v05, limits are not supported\")\n            LABELS = LABELS[:-2]\n            min = None\n            max = None\n        units_str = units[unit] if unit else \"\"\n        ret = await self._device._write_readline(\n            f\"{self._id}LR {statistics[var]} {units_str} {min or \"\"} {max or \"\"}\"\n        )\n        ret = ret.split()\n        ret[1] = next(\n            (code for code, value in statistics.items() if value == int(ret[1])), ret[1]\n        )\n        ret[2], ret[3] = float(ret[2]), float(ret[3])\n        return dict(zip(LABELS, ret))\n\n    async def max_ramp_rate(\n        self, max: float | None = None, unit: str | None = None\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets/Sets how fast controller moves to new setpoint.\n\n        Example:\n            df = run(dev.pmax_ramp_rate, 0, 'SCCM/s')\n\n        Args:\n            max (float): Indicates step size for movement to setpoint. 0 to disable ramping (still must include unit)\n            unit (str): unit for rate\n\n        Returns:\n            dict[str, str | float]: Reports max ramp rate with unit\n        \"\"\"\n        if self._vers and self._vers &lt; 7.11:\n            raise VersionError(\"Version earlier than 7v11\")\n        LABELS = (\"Unit_ID\", \"Max_Ramp_Rate\", \"Unit_Code\", \"Time_Code\", \"Units\")\n        if unit:\n            unit = units[unit]\n        ret = await self._device._write_readline(\n            f\"{self._id}SR {max or \"\"} {unit or \"\"}\"\n        )\n        ret = ret.split()\n        ret[1] = float(ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def pdf_gains(\n        self,\n        save: bool | None = None,\n        p_gain: int | None = None,\n        d_gain: int | None = None,\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets/Sets the proportional and intregral gains of the PD/PDF controller.\n\n        Manual is incorrect, this does not have an insignifcant 0 in the command\n\n        Example:\n            df = run(dev.pd2i_gains, False, 502, 5632)\n\n        Args:\n            save (bool): Whether to save gains on power-up\n            p_gain (int): Integral gain. Range is 0 to 65535\n            d_gain (int): Proportional gain. Range is 0 to 65535\n\n        Returns:\n            dict[str, str | float]: Reports P and D gains\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"P_Gain\", \"D_Gain\")\n        save_str = \"1\" if save else \"0\" if save is not None else \"\"\n        ret = await self._device._write_readline(\n            f\"{self._id}LCGD {save_str} {p_gain or \"\"} {d_gain or \"\"}\"\n        )\n        ret = ret.split()\n        ret[1], ret[2] = int(ret[1]), int(ret[2])\n        return dict(zip(LABELS, ret))\n\n    async def pd2i_gains(\n        self,\n        save: bool | None = None,\n        p_gain: int | None = None,\n        i_gain: int | None = None,\n        d_gain: int | None = None,\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets/Sets the proportional, intregral, and derivative gains of the PD2I controller.\n\n        Example:\n            df = run(dev.pd2i_gains, False, 502, 0, 5632)\n\n        Note:\n            **Setting is nonfunctional**\n\n        Args:\n            save (bool): Whether to save gains on power-up\n            p_gain (int): Proportional gain. Range is 0 to 65535\n            i_gain (int): Integral gain. Range is 0 to 65535\n            d_gain (int): Derivative gain. Range is 0 to 65535. Optional.\n\n        Returns:\n            dict[str, str | float]: Reports P, I, and D gains\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"P_Gain\", \"I_Gain\", \"D_Gain\")\n        save_str = \"1\" if save else \"0\" if save is not None else \"\"\n        ret = await self._device._write_readline(\n            f\"{self._id}LCG {save_str} {p_gain or \"\"} {i_gain or \"\"} {d_gain or \"\"}\"\n        )\n        ret = ret.split()\n        ret[1], ret[2], ret[3] = int(ret[1]), int(ret[2]), int(ret[3])\n        return dict(zip(LABELS, ret))\n\n    async def power_up_setpoint(self, val: float) -&gt; dict[str, str | float]:\n        \"\"\"Enables immediate setpoint on power-up.\n\n        Example:\n            df = run(dev.power_up_setpoint, 100) # Setpoint of 100 on startup\n\n        Note:\n            **Untested.**\n\n        Args:\n            val (float): Setpoint on power-up. 0 to disable start-up setpoint\n\n        Returns:\n            dict[str, str | float]: Dataframe with current (not power-up) setpoint\n        \"\"\"\n        if self._vers and self._vers &lt; 8.04:\n            raise VersionError(\"Version earlier than 8v04\")\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(f\"{self._id}SPUE {val}\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def overpressure(self, limit: float) -&gt; dict[str, str | float]:\n        \"\"\"Sets the overpressure limit of the device. Flow is stopped if pressure exceeds.\n\n        Example:\n            df = run(dev.overpressure, 0) # Disables overpressure\n\n        Note:\n            **Untested.**\n\n        Args:\n            limit (float): Upper limit of pressure. Disabled if above pressure full scale or &lt;= 0\n\n        Returns:\n            dict[str, str | float]: Dataframe\n        \"\"\"\n        if self._vers and self._vers &lt; 5.09:\n            raise VersionError(\"Version earlier than 5v09\")\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(f\"{self._id}OPL {limit}\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def ramp(\n        self,\n        up: bool | None = None,\n        down: bool | None = None,\n        zero: bool | None = None,\n        power_up: bool | None = None,\n    ) -&gt; dict[str, str]:\n        \"\"\"Gets/Sets the ramp settings of the device.\n\n        Example:\n            df = run(dev.ramp, True, True, True, True) # Enable 'follow ramp rate' for all settings\n\n        Args:\n            up (bool): When setpoint is made higher. Disabled = immediate move. Enabled = Follow ramp rate\n            down (bool): When setpoint is made lower. Disabled = immediate move. Enabled = Follow ramp rate\n            zero (bool): When setpoint is zero. Disabled = immediate move. Enabled = Follow ramp rate\n            power_up (bool): To setpoint on power-up. Disabled = immediate move. Enabled = Follow ramp rate\n\n        Returns:\n            dict[str, str]: Dataframe\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Ramp_Up\", \"Ramp_Down\", \"Zero_Ramp\", \"Power_Up_Ramp\")\n        up_str = \"1\" if up else \"0\" if up is not None else \"\"\n        down_str = \"1\" if down else \"0\" if down is not None else \"\"\n        zero_str = \"1\" if zero else \"0\" if zero is not None else \"\"\n        power_up_str = \"1\" if power_up else \"0\" if power_up is not None else \"\"\n        ret = await self._device._write_readline(\n            f\"{self._id}LSRC {up_str} {down_str} {zero_str} {power_up_str}\"\n        )\n        output_mapping = {\"1\": \"Enabled\", \"0\": \"Disabled\"}\n        ret = ret.split()\n        ret = [output_mapping.get(str(val), val) for val in ret]\n        return dict(zip(LABELS, ret))\n\n    async def setpoint_source(self, mode: str | None = None) -&gt; dict[str, str]:\n        \"\"\"Gets/Sets how the setpoint is given to the controller.\n\n        Example:\n            df = run(dev.setpoint_source, \"A\") # Setpoint from analog input\n\n        Note:\n            **This appears to function for the meter for some reason**\n\n        Args:\n            mode (str): Desired source for setpoint input\n\n                - A for Analog\n                - S for Display or Serial Communications. Saves and restores setpoint on pwower-up\n                - U for Display or Serial Communications. Does not save.\n\n        Returns:\n            dict[str, str]: Setpoint source mode\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Mode\")\n        ret = await self._device._write_readline(f\"{self._id}LSS {mode or \"\"}\")\n        ret = ret.split()\n        mapping = {\n            \"A\": \"Analog\",\n            \"S\": \"Serial/Display_Saved\",\n            \"U\": \"Serial/Display_Unsaved\",\n        }\n        ret[1] = mapping.get(ret[1], ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def valve_offset(\n        self,\n        save: bool | None = None,\n        initial_offset: float | None = None,\n        closed_offset: float | None = None,\n    ) -&gt; dict[str, str | float]:\n        \"\"\"Gets/Sets how much power driven to valve when first opened or considered closed.\n\n        Example:\n            df = run(dev.valve_offset, False, 50, 10)  # (Do not save, 50% to open, 10% for closed\n\n        Args:\n            save (bool): Whether to save offset values on power-up\n            initial_offset (float): 0-100% of total electrcity to first open closed valve\n            closed_offset (float): 0-100% of total electrcity for device to consider valve closed\n\n        Returns:\n            dict[str, str | float]: Offset values\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Init_Offset_(%)\", \"Closed_Offset_(%)\")\n        save_str = \"0 1\" if save else \"0 0\" if save is not None else \"\"\n        ret = await self._device._write_readline(\n            f\"{self._id}LCVO {save_str} {initial_offset or \"\"} {closed_offset or \"\"}\"\n        )\n        ret = ret.split()\n        ret[1], ret[2] = float(ret[1]), float(ret[2])\n        return dict(zip(LABELS, ret))\n\n    async def zero_pressure_control(self, enable: bool | None = None) -&gt; dict[str, str]:\n        \"\"\"Gets/Sets how controller reacts to 0 Pressure setpoint.\n\n        Example:\n            df = run(dev.zero_pressure_control, True)\n\n        Args:\n            enable (bool): If disabled, valve opens/closes completely. If enabled, uses close-loop\n\n        Returns:\n            dict[str, str]: If active control is active or not\n        \"\"\"\n        if self._vers and self._vers &lt; 10.05:\n            raise VersionError(\"Version earlier than 10v05\")\n        LABELS = (\"Unit_ID\", \"Active_Ctrl\")\n        enable_str = \"1\" if enable else \"0\" if enable is not None else \"\"\n        ret = await self._device._write_readline(f\"{self._id}LCZA {enable_str}\")\n        ret = ret.split()\n        output_mapping = {\"1\": \"Enabled\", \"0\": \"Disabled\"}\n        ret[1] = output_mapping.get(str(ret[1]), ret[1])\n        return dict(zip(LABELS, ret))\n\n    async def cancel_valve_hold(self) -&gt; dict[str, str | float]:\n        \"\"\"Removes valve holds on the device.\n\n        Example:\n            df = run(dev.cancel_valve_hold)\n\n        Note:\n             **Untested.**\n\n        Returns:\n             dict[str, str | float]: Returns data frame without 'hold' status\n        \"\"\"\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(f\"{self._id}C\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def exhaust(self) -&gt; dict[str, str | float]:\n        \"\"\"Closes upstream valve and opens downstream 100%.\n\n        Example:\n            df = run(dev.exhaust)\n\n        Note:\n            **Untested.**\n\n        Returns:\n            dict[str, str | float]: Returns data frame with 'hold' status\n        \"\"\"\n        if self._vers and self._vers &lt; 4.37:\n            raise VersionError(\"Version earlier than 4v37\")\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(f\"{self._id}E\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def hold_valves(self) -&gt; dict[str, str | float]:\n        \"\"\"Maintains valve position.\n\n        Example:\n            df = run(dev.hold_valves)\n\n        Note:\n             **Untested.**\n\n        Returns:\n             dict[str, str | float]: Returns data frame with 'hold' status\n        \"\"\"\n        if self._vers and self._vers &lt; 5.07:\n            raise VersionError(\"Version earlier than 5v07\")\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(f\"{self._id}HP\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def hold_valves_closed(self) -&gt; dict[str, str | float]:\n        \"\"\"Maintains closed valve position.\n\n        Example:\n            df = run(dev.hold_valves_closed)\n\n        Note:\n            **Untested.**\n\n        Returns:\n            dict[str, str | float]: Returns data frame with 'hold' status\n        \"\"\"\n        if self._vers and self._vers &lt; 5.07:\n            raise VersionError(\"Version earlier than 5v07\")\n        if self._df_format is None:\n            await self.get_df_format()\n        ret = await self._device._write_readline(f\"{self._id}HC\")\n        df = ret.split()\n        for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n            df[index] = float(df[index])\n        return dict(zip(self._df_format, df))\n\n    async def query_valve(self) -&gt; dict[str, str | float]:\n        \"\"\"Gives the percent of total electrciity sent to valve(s).\n\n        Example:\n            df = run(dev.query_valve)\n\n        Note:\n            **Untested.**\n\n        Returns:\n            dict[str, str | float]: Valve drive percentages\n        \"\"\"\n        if self._vers and self._vers &lt; 8.18:\n            raise VersionError(\"Version earlier than 8v18\")\n        LABELS = (\"Unit_ID\", \"Upstream_Valve\", \"Downstream_Valve\", \"Exhaust_Valve\")\n        ret = await self._device._write_readline(f\"{self._id}VD\")\n        ret = ret.split()\n        for i in range(len(ret)):\n            if not i == 0:\n                ret[i] = float(ret[i])\n        return dict(zip(LABELS, ret))\n\n    async def set(self, comm: dict[str, list[str | float]]) -&gt; dict[str, str | float]:\n        \"\"\"Sets the values of measurements for the device.\n\n        Example:\n            df = run(dev.set, {\"Setpt\": 50})\n            df = run(dev.set, {\"Setpt\": [1.5, \"SSCS\"]})\n\n        Args:\n            comm (dict[str, list[str | float]]): Dictionary with command to set as key, parameters as values. Use a list for multiple parameters\n\n        Returns:\n            dict[str, str | float]: Response of setting function\n        \"\"\"\n        resp: dict[str, str | float] = {}\n        for meas in list(comm.keys()):\n            comm[meas] = (\n                [comm[meas]] if not isinstance(comm[meas], list) else comm[meas]\n            )\n            while len(comm[meas]) &lt; 2:\n                comm[meas].append(\"\")\n            upper_meas = str(meas).upper()\n            # Set gas - Param1 = gas: str = \"\", Param2 = save: bool = \"\"\n            if upper_meas == \"GAS\":\n                resp.update(await self.gas(str(comm[meas][0]), str(comm[meas][1])))\n            # Set setpoint - Param1 = value: float = \"\", Param2 = unit: str = \"\"\n            elif upper_meas in (\"SETPOINT\", \"SETPT\"):\n                resp.update(await self.setpoint(str(comm[meas][0]), str(comm[meas][1])))\n            # Set loop control variable - Param1 = statistic: str = \"\"\n            elif upper_meas in (\"LOOP\", \"LOOP_CTRL\"):\n                resp.update(await self.loop_control_var(str(comm[meas][0])))\n        return resp\n\n    async def get(self, measurements: list[str] = [\"@\"]) -&gt; dict[str, str | float]:\n        \"\"\"Gets the value of a measurement from the device.\n\n        Example:\n            df = run(dev.get, [\"Setpt\", \"Mass_Flow\"])\n\n        Args:\n            measurements (list[str]): List of measurements to get\n\n        Returns:\n            dict[str, str | float]: Dictionary of measurements\n        \"\"\"\n        resp: dict[str, str | float] = {}\n        flag = 0\n        reqs = []\n        # Request\n        if not measurements:\n            measurements = [\"@\"]\n        for meas in measurements:\n            if meas and meas in statistics:\n                reqs.append(meas)\n            elif meas.upper() == \"GAS\":\n                resp.update(await self.gas())\n            elif meas.upper() in [\"SETPOINT\", \"STPT\"]:\n                resp.update(await self.setpoint())\n            elif flag == 0:\n                resp.update(await self.poll())\n                flag = 1\n        i = 0\n        while i * 13 &lt; len(reqs):\n            resp.update(await self.request(reqs[13 * i : 13 + 13 * i]))\n            i += 1\n        return resp\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.__init__","title":"<code>__init__(device, dev_info, id='A', **kwargs)</code>","text":"<p>Connects to the flow controller.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Device</code> <p>The Device object.</p> required <code>dev_info</code> <code>dict</code> <p>The device information dictionary.</p> required <code>id</code> <code>str</code> <p>Unit ID of Alicat flow controller. Defaults to \"A\".</p> <code>'A'</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>pyalicat/device.py</code> <pre><code>def __init__(\n    self, device: SerialDevice, dev_info: dict, id: str = \"A\", **kwargs: Any\n) -&gt; None:\n    \"\"\"Connects to the flow controller.\n\n    Args:\n        device (Device): The Device object.\n        dev_info (dict): The device information dictionary.\n        id (str, optional): Unit ID of Alicat flow controller. Defaults to \"A\".\n        **kwargs (Any): Additional keyword arguments.\n    \"\"\"\n    super().__init__(device, dev_info, id, **kwargs)\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.batch","title":"<code>batch(totalizer=1, batch_vol=None, unit=None)</code>  <code>async</code>","text":"<p>Directs controller to flow a set amount then close the valve.</p> Example <p>df = run(dev.batch, 1, 100, \"SCCM\")</p> Note <p>Untested.</p> <p>Parameters:</p> Name Type Description Default <code>totalizer</code> <code>int</code> <p>Totalizer (1 or 2) to use/query. Defaults to 1.</p> <code>1</code> <code>batch_vol</code> <code>int</code> <p>Size of desired batch flow. Set to 0 to disable batch.</p> <code>None</code> <code>unit</code> <code>str</code> <p>Volume units for flow.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Reports totalizer, batch size, units.</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def batch(\n    self, totalizer: int = 1, batch_vol: int | None = None, unit: str | None = None\n) -&gt; dict[str, str | float]:\n    \"\"\"Directs controller to flow a set amount then close the valve.\n\n    Example:\n        df = run(dev.batch, 1, 100, \"SCCM\")\n\n    Note:\n        **Untested.**\n\n    Args:\n        totalizer (int): Totalizer (1 or 2) to use/query. Defaults to 1.\n        batch_vol (int): Size of desired batch flow. Set to 0 to disable batch.\n        unit (str): Volume units for flow.\n\n    Returns:\n        dict[str, str | float]: Reports totalizer, batch size, units.\n    \"\"\"\n    if self._vers and self._vers &lt; 10.00:\n        raise VersionError(\"Version earlier than 10v00\")\n    LABELS = (\"Unit_ID\", \"Totalizer\", \"Batch_Size\", \"Unit_Code\", \"Unit_Label\")\n    unit_str = units[unit] if unit else \"\"\n    ret = await self._device._write_readline(\n        f\"{self._id}TB {totalizer} {batch_vol or \"\"} {unit_str}\"\n    )\n    return dict(zip(LABELS, ret.split()))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.cancel_valve_hold","title":"<code>cancel_valve_hold()</code>  <code>async</code>","text":"<p>Removes valve holds on the device.</p> Example <p>df = run(dev.cancel_valve_hold)</p> Note <p>Untested.</p> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Returns data frame without 'hold' status</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def cancel_valve_hold(self) -&gt; dict[str, str | float]:\n    \"\"\"Removes valve holds on the device.\n\n    Example:\n        df = run(dev.cancel_valve_hold)\n\n    Note:\n         **Untested.**\n\n    Returns:\n         dict[str, str | float]: Returns data frame without 'hold' status\n    \"\"\"\n    if self._df_format is None:\n        await self.get_df_format()\n    ret = await self._device._write_readline(f\"{self._id}C\")\n    df = ret.split()\n    for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n        df[index] = float(df[index])\n    return dict(zip(self._df_format, df))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.deadband_limit","title":"<code>deadband_limit(save=None, limit=None)</code>  <code>async</code>","text":"<p>Gets/Sets the range the controller allows for drift around setpoint.</p> Example <p>df = run(dev.deadband_mode, False, 0)</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool</code> <p>Whether to save the deadband limit on startup</p> <code>None</code> <code>limit</code> <code>float</code> <p>Value of deadband limit</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Reports deadband with units</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def deadband_limit(\n    self, save: bool | None = None, limit: float | None = None\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets/Sets the range the controller allows for drift around setpoint.\n\n    Example:\n        df = run(dev.deadband_mode, False, 0)\n\n    Args:\n        save (bool): Whether to save the deadband limit on startup\n        limit (float): Value of deadband limit\n\n    Returns:\n        dict[str, str | float]: Reports deadband with units\n    \"\"\"\n    LABELS = (\"Unit_ID\", \"Deadband\", \"Unit_Code\", \"Unit_Label\")\n    save_str = \"1\" if save else \"0\" if save is not None else \"\"\n    ret = await self._device._write_readline(\n        f\"{self._id}LCDB {save_str} {limit or \"\"}\"\n    )\n    ret = ret.split()\n    ret[1] = float(ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.deadband_mode","title":"<code>deadband_mode(mode=None)</code>  <code>async</code>","text":"<p>Gets/Sets the reaction the controller has for values around setpoint.</p> Example <p>df = run(dev.deadband_mode, \"Close\")</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>\"Hold\" or \"Current\" holds valve and current positions until outside the limits. \"Close\" closes valve until outside the limits.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Reports mode</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def deadband_mode(self, mode: str | None = None) -&gt; dict[str, str]:\n    \"\"\"Gets/Sets the reaction the controller has for values around setpoint.\n\n    Example:\n        df = run(dev.deadband_mode, \"Close\")\n\n    Args:\n        mode (str): \"Hold\" or \"Current\" holds valve and current positions until outside the limits. \"Close\" closes valve until outside the limits.\n\n    Returns:\n        dict[str, str]: Reports mode\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Mode\")\n    if mode:\n        mode = (\n            \"1\"\n            if mode.upper() in [\"HOLD\", \"CURRENT\"]\n            else \"2\"\n            if mode.upper() in [\"CLOSE\"]\n            else mode\n        )\n    ret = await self._device._write_readline(f\"{self._id}LCDM {mode or \"\"}\")\n    ret = ret.split()\n    output_mapping = {\"1\": \"Hold valve at current\", \"2\": \"Close valve\"}\n    ret[1] = output_mapping.get(str(ret[1]), ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.exhaust","title":"<code>exhaust()</code>  <code>async</code>","text":"<p>Closes upstream valve and opens downstream 100%.</p> Example <p>df = run(dev.exhaust)</p> Note <p>Untested.</p> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Returns data frame with 'hold' status</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def exhaust(self) -&gt; dict[str, str | float]:\n    \"\"\"Closes upstream valve and opens downstream 100%.\n\n    Example:\n        df = run(dev.exhaust)\n\n    Note:\n        **Untested.**\n\n    Returns:\n        dict[str, str | float]: Returns data frame with 'hold' status\n    \"\"\"\n    if self._vers and self._vers &lt; 4.37:\n        raise VersionError(\"Version earlier than 4v37\")\n    if self._df_format is None:\n        await self.get_df_format()\n    ret = await self._device._write_readline(f\"{self._id}E\")\n    df = ret.split()\n    for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n        df[index] = float(df[index])\n    return dict(zip(self._df_format, df))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.get","title":"<code>get(measurements=['@'])</code>  <code>async</code>","text":"<p>Gets the value of a measurement from the device.</p> Example <p>df = run(dev.get, [\"Setpt\", \"Mass_Flow\"])</p> <p>Parameters:</p> Name Type Description Default <code>measurements</code> <code>list[str]</code> <p>List of measurements to get</p> <code>['@']</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Dictionary of measurements</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def get(self, measurements: list[str] = [\"@\"]) -&gt; dict[str, str | float]:\n    \"\"\"Gets the value of a measurement from the device.\n\n    Example:\n        df = run(dev.get, [\"Setpt\", \"Mass_Flow\"])\n\n    Args:\n        measurements (list[str]): List of measurements to get\n\n    Returns:\n        dict[str, str | float]: Dictionary of measurements\n    \"\"\"\n    resp: dict[str, str | float] = {}\n    flag = 0\n    reqs = []\n    # Request\n    if not measurements:\n        measurements = [\"@\"]\n    for meas in measurements:\n        if meas and meas in statistics:\n            reqs.append(meas)\n        elif meas.upper() == \"GAS\":\n            resp.update(await self.gas())\n        elif meas.upper() in [\"SETPOINT\", \"STPT\"]:\n            resp.update(await self.setpoint())\n        elif flag == 0:\n            resp.update(await self.poll())\n            flag = 1\n    i = 0\n    while i * 13 &lt; len(reqs):\n        resp.update(await self.request(reqs[13 * i : 13 + 13 * i]))\n        i += 1\n    return resp\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.hold_valves","title":"<code>hold_valves()</code>  <code>async</code>","text":"<p>Maintains valve position.</p> Example <p>df = run(dev.hold_valves)</p> Note <p>Untested.</p> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Returns data frame with 'hold' status</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def hold_valves(self) -&gt; dict[str, str | float]:\n    \"\"\"Maintains valve position.\n\n    Example:\n        df = run(dev.hold_valves)\n\n    Note:\n         **Untested.**\n\n    Returns:\n         dict[str, str | float]: Returns data frame with 'hold' status\n    \"\"\"\n    if self._vers and self._vers &lt; 5.07:\n        raise VersionError(\"Version earlier than 5v07\")\n    if self._df_format is None:\n        await self.get_df_format()\n    ret = await self._device._write_readline(f\"{self._id}HP\")\n    df = ret.split()\n    for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n        df[index] = float(df[index])\n    return dict(zip(self._df_format, df))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.hold_valves_closed","title":"<code>hold_valves_closed()</code>  <code>async</code>","text":"<p>Maintains closed valve position.</p> Example <p>df = run(dev.hold_valves_closed)</p> Note <p>Untested.</p> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Returns data frame with 'hold' status</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def hold_valves_closed(self) -&gt; dict[str, str | float]:\n    \"\"\"Maintains closed valve position.\n\n    Example:\n        df = run(dev.hold_valves_closed)\n\n    Note:\n        **Untested.**\n\n    Returns:\n        dict[str, str | float]: Returns data frame with 'hold' status\n    \"\"\"\n    if self._vers and self._vers &lt; 5.07:\n        raise VersionError(\"Version earlier than 5v07\")\n    if self._df_format is None:\n        await self.get_df_format()\n    ret = await self._device._write_readline(f\"{self._id}HC\")\n    df = ret.split()\n    for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n        df[index] = float(df[index])\n    return dict(zip(self._df_format, df))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.is_model","title":"<code>is_model(model)</code>  <code>classmethod</code>","text":"<p>Checks if the flow meter is of a certain model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Model of flow meter.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if model matches.</p> Source code in <code>pyalicat/device.py</code> <pre><code>@classmethod\ndef is_model(cls, model: str) -&gt; bool:\n    \"\"\"Checks if the flow meter is of a certain model.\n\n    Args:\n        model (str): Model of flow meter.\n\n    Returns:\n        bool: True if model matches.\n    \"\"\"\n    models = [\" MC-\", \" MCS-\", \" MCQ-\", \" MCW-\"]\n    return any([bool(re.search(i, model)) for i in models])\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.loop_control_alg","title":"<code>loop_control_alg(algo=None)</code>  <code>async</code>","text":"<p>Gets/Sets the control algorithm the controller uses.</p> <ul> <li>algorithm 1 = PD/PDF</li> <li>algorithm 2 = PD2I</li> </ul> Example <p>df = run(dev.loop_control_alg, \"PD/PDF\")</p> <p>Parameters:</p> Name Type Description Default <code>algo</code> <code>str</code> <p>Algorithm used for loop control. \"PD\", \"PDF\", \"PD/PDF\", \"PD2I\"</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Reports algorithm</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def loop_control_alg(self, algo: str | None = None) -&gt; dict[str, str]:\n    \"\"\"Gets/Sets the control algorithm the controller uses.\n\n    - algorithm 1 = PD/PDF\n    - algorithm 2 = PD2I\n\n    Example:\n        df = run(dev.loop_control_alg, \"PD/PDF\")\n\n    Args:\n        algo (str): Algorithm used for loop control. \"PD\", \"PDF\", \"PD/PDF\", \"PD2I\"\n\n    Returns:\n        dict[str, str]: Reports algorithm\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Algorithm\")\n    if algo:\n        algo = (\n            \"2\"\n            if algo.upper() in [\"PD2I\"]\n            else \"1\"\n            if algo.upper() in [\"PD\", \"PDF\", \"PD/PDF\"]\n            else algo\n        )\n    ret = await self._device._write_readline(f\"{self._id}LCA {algo or \"\"}\")\n    ret = ret.split()\n    algorithm_mapping = {\"1\": \"PD/PDF\", \"2\": \"PD2I\"}\n    ret[1] = algorithm_mapping.get(str(ret[1]), ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.loop_control_range","title":"<code>loop_control_range(var=None, unit=None, min=None, max=None)</code>  <code>async</code>","text":"<p>Gets/Sets the control range of the statistic the setpoint controls.</p> Example <p>df = run(dev.loop_control_gains, 'Mass_Flow_Setpt', 'SCCM', 0, 500)</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>Desired statistic to be queried/modified</p> <code>None</code> <code>unit</code> <code>str</code> <p>Units of var</p> <code>None</code> <code>min</code> <code>float</code> <p>Min allowable setpoint</p> <code>None</code> <code>max</code> <code>float</code> <p>Max allowable setpoint</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Reports loop variable, units, min, and max</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def loop_control_range(\n    self,\n    var: str | None = None,\n    unit: str | None = None,\n    min: float | None = None,\n    max: float | None = None,\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets/Sets the control range of the statistic the setpoint controls.\n\n    Example:\n        df = run(dev.loop_control_gains, 'Mass_Flow_Setpt', 'SCCM', 0, 500)\n\n    Args:\n        var (str): Desired statistic to be queried/modified\n        unit (str): Units of var\n        min (float): Min allowable setpoint\n        max (float): Max allowable setpoint\n\n    Returns:\n        dict[str, str | float]: Reports loop variable, units, min, and max\n    \"\"\"\n    if self._vers and self._vers &lt; 9.00:\n        raise VersionError(\"Version earlier than 9v00\")\n    LABELS = (\"Unit_ID\", \"Loop_Var\", \"Min\", \"Max\", \"Unit_Code\", \"Unit_Label\")\n    if self._vers and self._vers &lt; 10.05:\n        warnings.warn(\"Version earlier than 10v05, limits are not supported\")\n        LABELS = LABELS[:-2]\n        min = None\n        max = None\n    units_str = units[unit] if unit else \"\"\n    ret = await self._device._write_readline(\n        f\"{self._id}LR {statistics[var]} {units_str} {min or \"\"} {max or \"\"}\"\n    )\n    ret = ret.split()\n    ret[1] = next(\n        (code for code, value in statistics.items() if value == int(ret[1])), ret[1]\n    )\n    ret[2], ret[3] = float(ret[2]), float(ret[3])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.loop_control_var","title":"<code>loop_control_var(var)</code>  <code>async</code>","text":"<p>Sets the statistic the setpoint controls.</p> Example <p>df = run(dev.loop_control_var, 'Mass_Flow_Setpt')</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>Desired statistic</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Reports new loop variable</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def loop_control_var(self, var: str) -&gt; dict[str, str]:\n    \"\"\"Sets the statistic the setpoint controls.\n\n    Example:\n        df = run(dev.loop_control_var, 'Mass_Flow_Setpt')\n\n    Args:\n        var (str): Desired statistic\n\n    Returns:\n        dict[str, str]: Reports new loop variable\n    \"\"\"\n    if self._vers and self._vers &lt; 9.00:\n        raise VersionError(\"Version earlier than 9v00\")\n    LABELS = (\"Unit_ID\", \"Loop_Var_Val\")\n    # If the user did not specify setpoint, assume Setpt\n    if var and var[-6:] != \"_Setpt\":\n        var += \"_Setpt\"\n    ret = await self._device._write_readline(f\"{self._id}LV {statistics[var]}\")\n    ret = ret.split()\n    ret[1] = next(\n        (code for code, value in statistics.items() if value == int(ret[1])), ret[1]\n    )\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.max_ramp_rate","title":"<code>max_ramp_rate(max=None, unit=None)</code>  <code>async</code>","text":"<p>Gets/Sets how fast controller moves to new setpoint.</p> Example <p>df = run(dev.pmax_ramp_rate, 0, 'SCCM/s')</p> <p>Parameters:</p> Name Type Description Default <code>max</code> <code>float</code> <p>Indicates step size for movement to setpoint. 0 to disable ramping (still must include unit)</p> <code>None</code> <code>unit</code> <code>str</code> <p>unit for rate</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Reports max ramp rate with unit</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def max_ramp_rate(\n    self, max: float | None = None, unit: str | None = None\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets/Sets how fast controller moves to new setpoint.\n\n    Example:\n        df = run(dev.pmax_ramp_rate, 0, 'SCCM/s')\n\n    Args:\n        max (float): Indicates step size for movement to setpoint. 0 to disable ramping (still must include unit)\n        unit (str): unit for rate\n\n    Returns:\n        dict[str, str | float]: Reports max ramp rate with unit\n    \"\"\"\n    if self._vers and self._vers &lt; 7.11:\n        raise VersionError(\"Version earlier than 7v11\")\n    LABELS = (\"Unit_ID\", \"Max_Ramp_Rate\", \"Unit_Code\", \"Time_Code\", \"Units\")\n    if unit:\n        unit = units[unit]\n    ret = await self._device._write_readline(\n        f\"{self._id}SR {max or \"\"} {unit or \"\"}\"\n    )\n    ret = ret.split()\n    ret[1] = float(ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.overpressure","title":"<code>overpressure(limit)</code>  <code>async</code>","text":"<p>Sets the overpressure limit of the device. Flow is stopped if pressure exceeds.</p> Example <p>df = run(dev.overpressure, 0) # Disables overpressure</p> Note <p>Untested.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>float</code> <p>Upper limit of pressure. Disabled if above pressure full scale or &lt;= 0</p> required <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Dataframe</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def overpressure(self, limit: float) -&gt; dict[str, str | float]:\n    \"\"\"Sets the overpressure limit of the device. Flow is stopped if pressure exceeds.\n\n    Example:\n        df = run(dev.overpressure, 0) # Disables overpressure\n\n    Note:\n        **Untested.**\n\n    Args:\n        limit (float): Upper limit of pressure. Disabled if above pressure full scale or &lt;= 0\n\n    Returns:\n        dict[str, str | float]: Dataframe\n    \"\"\"\n    if self._vers and self._vers &lt; 5.09:\n        raise VersionError(\"Version earlier than 5v09\")\n    if self._df_format is None:\n        await self.get_df_format()\n    ret = await self._device._write_readline(f\"{self._id}OPL {limit}\")\n    df = ret.split()\n    for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n        df[index] = float(df[index])\n    return dict(zip(self._df_format, df))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.pd2i_gains","title":"<code>pd2i_gains(save=None, p_gain=None, i_gain=None, d_gain=None)</code>  <code>async</code>","text":"<p>Gets/Sets the proportional, intregral, and derivative gains of the PD2I controller.</p> Example <p>df = run(dev.pd2i_gains, False, 502, 0, 5632)</p> Note <p>Setting is nonfunctional</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool</code> <p>Whether to save gains on power-up</p> <code>None</code> <code>p_gain</code> <code>int</code> <p>Proportional gain. Range is 0 to 65535</p> <code>None</code> <code>i_gain</code> <code>int</code> <p>Integral gain. Range is 0 to 65535</p> <code>None</code> <code>d_gain</code> <code>int</code> <p>Derivative gain. Range is 0 to 65535. Optional.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Reports P, I, and D gains</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def pd2i_gains(\n    self,\n    save: bool | None = None,\n    p_gain: int | None = None,\n    i_gain: int | None = None,\n    d_gain: int | None = None,\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets/Sets the proportional, intregral, and derivative gains of the PD2I controller.\n\n    Example:\n        df = run(dev.pd2i_gains, False, 502, 0, 5632)\n\n    Note:\n        **Setting is nonfunctional**\n\n    Args:\n        save (bool): Whether to save gains on power-up\n        p_gain (int): Proportional gain. Range is 0 to 65535\n        i_gain (int): Integral gain. Range is 0 to 65535\n        d_gain (int): Derivative gain. Range is 0 to 65535. Optional.\n\n    Returns:\n        dict[str, str | float]: Reports P, I, and D gains\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"P_Gain\", \"I_Gain\", \"D_Gain\")\n    save_str = \"1\" if save else \"0\" if save is not None else \"\"\n    ret = await self._device._write_readline(\n        f\"{self._id}LCG {save_str} {p_gain or \"\"} {i_gain or \"\"} {d_gain or \"\"}\"\n    )\n    ret = ret.split()\n    ret[1], ret[2], ret[3] = int(ret[1]), int(ret[2]), int(ret[3])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.pdf_gains","title":"<code>pdf_gains(save=None, p_gain=None, d_gain=None)</code>  <code>async</code>","text":"<p>Gets/Sets the proportional and intregral gains of the PD/PDF controller.</p> <p>Manual is incorrect, this does not have an insignifcant 0 in the command</p> Example <p>df = run(dev.pd2i_gains, False, 502, 5632)</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool</code> <p>Whether to save gains on power-up</p> <code>None</code> <code>p_gain</code> <code>int</code> <p>Integral gain. Range is 0 to 65535</p> <code>None</code> <code>d_gain</code> <code>int</code> <p>Proportional gain. Range is 0 to 65535</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Reports P and D gains</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def pdf_gains(\n    self,\n    save: bool | None = None,\n    p_gain: int | None = None,\n    d_gain: int | None = None,\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets/Sets the proportional and intregral gains of the PD/PDF controller.\n\n    Manual is incorrect, this does not have an insignifcant 0 in the command\n\n    Example:\n        df = run(dev.pd2i_gains, False, 502, 5632)\n\n    Args:\n        save (bool): Whether to save gains on power-up\n        p_gain (int): Integral gain. Range is 0 to 65535\n        d_gain (int): Proportional gain. Range is 0 to 65535\n\n    Returns:\n        dict[str, str | float]: Reports P and D gains\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"P_Gain\", \"D_Gain\")\n    save_str = \"1\" if save else \"0\" if save is not None else \"\"\n    ret = await self._device._write_readline(\n        f\"{self._id}LCGD {save_str} {p_gain or \"\"} {d_gain or \"\"}\"\n    )\n    ret = ret.split()\n    ret[1], ret[2] = int(ret[1]), int(ret[2])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.power_up_setpoint","title":"<code>power_up_setpoint(val)</code>  <code>async</code>","text":"<p>Enables immediate setpoint on power-up.</p> Example <p>df = run(dev.power_up_setpoint, 100) # Setpoint of 100 on startup</p> Note <p>Untested.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>float</code> <p>Setpoint on power-up. 0 to disable start-up setpoint</p> required <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Dataframe with current (not power-up) setpoint</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def power_up_setpoint(self, val: float) -&gt; dict[str, str | float]:\n    \"\"\"Enables immediate setpoint on power-up.\n\n    Example:\n        df = run(dev.power_up_setpoint, 100) # Setpoint of 100 on startup\n\n    Note:\n        **Untested.**\n\n    Args:\n        val (float): Setpoint on power-up. 0 to disable start-up setpoint\n\n    Returns:\n        dict[str, str | float]: Dataframe with current (not power-up) setpoint\n    \"\"\"\n    if self._vers and self._vers &lt; 8.04:\n        raise VersionError(\"Version earlier than 8v04\")\n    if self._df_format is None:\n        await self.get_df_format()\n    ret = await self._device._write_readline(f\"{self._id}SPUE {val}\")\n    df = ret.split()\n    for index in [idx for idx, s in enumerate(self._df_ret) if \"decimal\" in s]:\n        df[index] = float(df[index])\n    return dict(zip(self._df_format, df))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.query_valve","title":"<code>query_valve()</code>  <code>async</code>","text":"<p>Gives the percent of total electrciity sent to valve(s).</p> Example <p>df = run(dev.query_valve)</p> Note <p>Untested.</p> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Valve drive percentages</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def query_valve(self) -&gt; dict[str, str | float]:\n    \"\"\"Gives the percent of total electrciity sent to valve(s).\n\n    Example:\n        df = run(dev.query_valve)\n\n    Note:\n        **Untested.**\n\n    Returns:\n        dict[str, str | float]: Valve drive percentages\n    \"\"\"\n    if self._vers and self._vers &lt; 8.18:\n        raise VersionError(\"Version earlier than 8v18\")\n    LABELS = (\"Unit_ID\", \"Upstream_Valve\", \"Downstream_Valve\", \"Exhaust_Valve\")\n    ret = await self._device._write_readline(f\"{self._id}VD\")\n    ret = ret.split()\n    for i in range(len(ret)):\n        if not i == 0:\n            ret[i] = float(ret[i])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.ramp","title":"<code>ramp(up=None, down=None, zero=None, power_up=None)</code>  <code>async</code>","text":"<p>Gets/Sets the ramp settings of the device.</p> Example <p>df = run(dev.ramp, True, True, True, True) # Enable 'follow ramp rate' for all settings</p> <p>Parameters:</p> Name Type Description Default <code>up</code> <code>bool</code> <p>When setpoint is made higher. Disabled = immediate move. Enabled = Follow ramp rate</p> <code>None</code> <code>down</code> <code>bool</code> <p>When setpoint is made lower. Disabled = immediate move. Enabled = Follow ramp rate</p> <code>None</code> <code>zero</code> <code>bool</code> <p>When setpoint is zero. Disabled = immediate move. Enabled = Follow ramp rate</p> <code>None</code> <code>power_up</code> <code>bool</code> <p>To setpoint on power-up. Disabled = immediate move. Enabled = Follow ramp rate</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Dataframe</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def ramp(\n    self,\n    up: bool | None = None,\n    down: bool | None = None,\n    zero: bool | None = None,\n    power_up: bool | None = None,\n) -&gt; dict[str, str]:\n    \"\"\"Gets/Sets the ramp settings of the device.\n\n    Example:\n        df = run(dev.ramp, True, True, True, True) # Enable 'follow ramp rate' for all settings\n\n    Args:\n        up (bool): When setpoint is made higher. Disabled = immediate move. Enabled = Follow ramp rate\n        down (bool): When setpoint is made lower. Disabled = immediate move. Enabled = Follow ramp rate\n        zero (bool): When setpoint is zero. Disabled = immediate move. Enabled = Follow ramp rate\n        power_up (bool): To setpoint on power-up. Disabled = immediate move. Enabled = Follow ramp rate\n\n    Returns:\n        dict[str, str]: Dataframe\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Ramp_Up\", \"Ramp_Down\", \"Zero_Ramp\", \"Power_Up_Ramp\")\n    up_str = \"1\" if up else \"0\" if up is not None else \"\"\n    down_str = \"1\" if down else \"0\" if down is not None else \"\"\n    zero_str = \"1\" if zero else \"0\" if zero is not None else \"\"\n    power_up_str = \"1\" if power_up else \"0\" if power_up is not None else \"\"\n    ret = await self._device._write_readline(\n        f\"{self._id}LSRC {up_str} {down_str} {zero_str} {power_up_str}\"\n    )\n    output_mapping = {\"1\": \"Enabled\", \"0\": \"Disabled\"}\n    ret = ret.split()\n    ret = [output_mapping.get(str(val), val) for val in ret]\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.set","title":"<code>set(comm)</code>  <code>async</code>","text":"<p>Sets the values of measurements for the device.</p> Example <p>df = run(dev.set, {\"Setpt\": 50}) df = run(dev.set, {\"Setpt\": [1.5, \"SSCS\"]})</p> <p>Parameters:</p> Name Type Description Default <code>comm</code> <code>dict[str, list[str | float]]</code> <p>Dictionary with command to set as key, parameters as values. Use a list for multiple parameters</p> required <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Response of setting function</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def set(self, comm: dict[str, list[str | float]]) -&gt; dict[str, str | float]:\n    \"\"\"Sets the values of measurements for the device.\n\n    Example:\n        df = run(dev.set, {\"Setpt\": 50})\n        df = run(dev.set, {\"Setpt\": [1.5, \"SSCS\"]})\n\n    Args:\n        comm (dict[str, list[str | float]]): Dictionary with command to set as key, parameters as values. Use a list for multiple parameters\n\n    Returns:\n        dict[str, str | float]: Response of setting function\n    \"\"\"\n    resp: dict[str, str | float] = {}\n    for meas in list(comm.keys()):\n        comm[meas] = (\n            [comm[meas]] if not isinstance(comm[meas], list) else comm[meas]\n        )\n        while len(comm[meas]) &lt; 2:\n            comm[meas].append(\"\")\n        upper_meas = str(meas).upper()\n        # Set gas - Param1 = gas: str = \"\", Param2 = save: bool = \"\"\n        if upper_meas == \"GAS\":\n            resp.update(await self.gas(str(comm[meas][0]), str(comm[meas][1])))\n        # Set setpoint - Param1 = value: float = \"\", Param2 = unit: str = \"\"\n        elif upper_meas in (\"SETPOINT\", \"SETPT\"):\n            resp.update(await self.setpoint(str(comm[meas][0]), str(comm[meas][1])))\n        # Set loop control variable - Param1 = statistic: str = \"\"\n        elif upper_meas in (\"LOOP\", \"LOOP_CTRL\"):\n            resp.update(await self.loop_control_var(str(comm[meas][0])))\n    return resp\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.setpoint","title":"<code>setpoint(value=None, unit=None)</code>  <code>async</code>","text":"<p>Gets/Sets the setpoint of the device.</p> Example <p>df = run(dev.setpoint, 50, \"SCCM\")</p> Note <p>Devices with firmware versions 9.00 or greater should use this method</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Desired setpoint value for the controller. Set to 0 to close valve.</p> <code>None</code> <code>unit</code> <code>str</code> <p>Set setpoint units.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Reports setpoint with units</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def setpoint(\n    self, value: float | None = None, unit: str | None = None\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets/Sets the setpoint of the device.\n\n    Example:\n        df = run(dev.setpoint, 50, \"SCCM\")\n\n    Note:\n        Devices with firmware versions 9.00 or greater should use this method\n\n    Args:\n        value (float): Desired setpoint value for the controller. Set to 0 to close valve.\n        unit (str): Set setpoint units.\n\n    Returns:\n        dict[str, str | float]: Reports setpoint with units\n    \"\"\"\n    if self._vers and self._vers &lt; 9.00:\n        if value is None:\n            raise ValueError(\"Query setpoint is not supported for this software\")\n        else:\n            warnings.warn(\"Version earlier than 9v00, running Change Setpoint\")\n            return await self.change_setpoint(value)\n    LABELS = (\n        \"Unit_ID\",\n        \"Curr_Setpt\",\n        \"Requested_Setpt\",\n        \"Unit_Code\",\n        \"Unit_Label\",\n    )\n    ret = await self._device._write_readline(\n        f\"{self._id}LS {value or \"\"} {units[unit]}\"\n    )\n    if ret == \"?\":\n        raise ValueError(\"Invalid setpoint value\")\n    ret = ret.split()\n    ret[1], ret[2] = float(ret[1]), float(ret[2])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.setpoint_source","title":"<code>setpoint_source(mode=None)</code>  <code>async</code>","text":"<p>Gets/Sets how the setpoint is given to the controller.</p> Example <p>df = run(dev.setpoint_source, \"A\") # Setpoint from analog input</p> Note <p>This appears to function for the meter for some reason</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Desired source for setpoint input</p> <ul> <li>A for Analog</li> <li>S for Display or Serial Communications. Saves and restores setpoint on pwower-up</li> <li>U for Display or Serial Communications. Does not save.</li> </ul> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Setpoint source mode</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def setpoint_source(self, mode: str | None = None) -&gt; dict[str, str]:\n    \"\"\"Gets/Sets how the setpoint is given to the controller.\n\n    Example:\n        df = run(dev.setpoint_source, \"A\") # Setpoint from analog input\n\n    Note:\n        **This appears to function for the meter for some reason**\n\n    Args:\n        mode (str): Desired source for setpoint input\n\n            - A for Analog\n            - S for Display or Serial Communications. Saves and restores setpoint on pwower-up\n            - U for Display or Serial Communications. Does not save.\n\n    Returns:\n        dict[str, str]: Setpoint source mode\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Mode\")\n    ret = await self._device._write_readline(f\"{self._id}LSS {mode or \"\"}\")\n    ret = ret.split()\n    mapping = {\n        \"A\": \"Analog\",\n        \"S\": \"Serial/Display_Saved\",\n        \"U\": \"Serial/Display_Unsaved\",\n    }\n    ret[1] = mapping.get(ret[1], ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.valve_offset","title":"<code>valve_offset(save=None, initial_offset=None, closed_offset=None)</code>  <code>async</code>","text":"<p>Gets/Sets how much power driven to valve when first opened or considered closed.</p> Example <p>df = run(dev.valve_offset, False, 50, 10)  # (Do not save, 50% to open, 10% for closed</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool</code> <p>Whether to save offset values on power-up</p> <code>None</code> <code>initial_offset</code> <code>float</code> <p>0-100% of total electrcity to first open closed valve</p> <code>None</code> <code>closed_offset</code> <code>float</code> <p>0-100% of total electrcity for device to consider valve closed</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>dict[str, str | float]: Offset values</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def valve_offset(\n    self,\n    save: bool | None = None,\n    initial_offset: float | None = None,\n    closed_offset: float | None = None,\n) -&gt; dict[str, str | float]:\n    \"\"\"Gets/Sets how much power driven to valve when first opened or considered closed.\n\n    Example:\n        df = run(dev.valve_offset, False, 50, 10)  # (Do not save, 50% to open, 10% for closed\n\n    Args:\n        save (bool): Whether to save offset values on power-up\n        initial_offset (float): 0-100% of total electrcity to first open closed valve\n        closed_offset (float): 0-100% of total electrcity for device to consider valve closed\n\n    Returns:\n        dict[str, str | float]: Offset values\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Init_Offset_(%)\", \"Closed_Offset_(%)\")\n    save_str = \"0 1\" if save else \"0 0\" if save is not None else \"\"\n    ret = await self._device._write_readline(\n        f\"{self._id}LCVO {save_str} {initial_offset or \"\"} {closed_offset or \"\"}\"\n    )\n    ret = ret.split()\n    ret[1], ret[2] = float(ret[1]), float(ret[2])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowController.zero_pressure_control","title":"<code>zero_pressure_control(enable=None)</code>  <code>async</code>","text":"<p>Gets/Sets how controller reacts to 0 Pressure setpoint.</p> Example <p>df = run(dev.zero_pressure_control, True)</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>If disabled, valve opens/closes completely. If enabled, uses close-loop</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: If active control is active or not</p> Source code in <code>pyalicat/device.py</code> <pre><code>async def zero_pressure_control(self, enable: bool | None = None) -&gt; dict[str, str]:\n    \"\"\"Gets/Sets how controller reacts to 0 Pressure setpoint.\n\n    Example:\n        df = run(dev.zero_pressure_control, True)\n\n    Args:\n        enable (bool): If disabled, valve opens/closes completely. If enabled, uses close-loop\n\n    Returns:\n        dict[str, str]: If active control is active or not\n    \"\"\"\n    if self._vers and self._vers &lt; 10.05:\n        raise VersionError(\"Version earlier than 10v05\")\n    LABELS = (\"Unit_ID\", \"Active_Ctrl\")\n    enable_str = \"1\" if enable else \"0\" if enable is not None else \"\"\n    ret = await self._device._write_readline(f\"{self._id}LCZA {enable_str}\")\n    ret = ret.split()\n    output_mapping = {\"1\": \"Enabled\", \"0\": \"Disabled\"}\n    ret[1] = output_mapping.get(str(ret[1]), ret[1])\n    return dict(zip(LABELS, ret))\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowMeter","title":"<code>FlowMeter</code>","text":"<p>               Bases: <code>Device</code></p> <p>A class used to represent a flow meter.</p> Source code in <code>pyalicat/device.py</code> <pre><code>class FlowMeter(Device):\n    \"\"\"A class used to represent a flow meter.\"\"\"\n\n    @classmethod\n    def is_model(cls, model: str) -&gt; bool:\n        \"\"\"Checks if the flow meter is of a certain model.\n\n        Args:\n            model (str): Model of flow meter.\n\n        Returns:\n            bool: True if model matches.\n        \"\"\"\n        models = [\" M-\", \" MS-\", \" MQ-\", \" MW-\"]\n        return any([bool(re.search(i, model)) for i in models])\n\n    def __init__(\n        self, device: SerialDevice, dev_info: dict, id: str = \"A\", **kwargs: Any\n    ) -&gt; None:\n        \"\"\"Connects to the flow device.\n\n        Args:\n            device (Device): The Device object.\n            dev_info (dict): The device information dictionary.\n            id (str, optional): Unit ID of Alicat flow device. Defaults to \"A\".\n            **kwargs (Any): Additional keyword arguments.\n        \"\"\"\n        super().__init__(device, dev_info, id, **kwargs)\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowMeter.__init__","title":"<code>__init__(device, dev_info, id='A', **kwargs)</code>","text":"<p>Connects to the flow device.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Device</code> <p>The Device object.</p> required <code>dev_info</code> <code>dict</code> <p>The device information dictionary.</p> required <code>id</code> <code>str</code> <p>Unit ID of Alicat flow device. Defaults to \"A\".</p> <code>'A'</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>pyalicat/device.py</code> <pre><code>def __init__(\n    self, device: SerialDevice, dev_info: dict, id: str = \"A\", **kwargs: Any\n) -&gt; None:\n    \"\"\"Connects to the flow device.\n\n    Args:\n        device (Device): The Device object.\n        dev_info (dict): The device information dictionary.\n        id (str, optional): Unit ID of Alicat flow device. Defaults to \"A\".\n        **kwargs (Any): Additional keyword arguments.\n    \"\"\"\n    super().__init__(device, dev_info, id, **kwargs)\n</code></pre>"},{"location":"device-reference/#pyalicat.device.FlowMeter.is_model","title":"<code>is_model(model)</code>  <code>classmethod</code>","text":"<p>Checks if the flow meter is of a certain model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Model of flow meter.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if model matches.</p> Source code in <code>pyalicat/device.py</code> <pre><code>@classmethod\ndef is_model(cls, model: str) -&gt; bool:\n    \"\"\"Checks if the flow meter is of a certain model.\n\n    Args:\n        model (str): Model of flow meter.\n\n    Returns:\n        bool: True if model matches.\n    \"\"\"\n    models = [\" M-\", \" MS-\", \" MQ-\", \" MW-\"]\n    return any([bool(re.search(i, model)) for i in models])\n</code></pre>"},{"location":"device-reference/#pyalicat.device.VersionError","title":"<code>VersionError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the version of the device does not support command.</p> Source code in <code>pyalicat/device.py</code> <pre><code>class VersionError(Exception):\n    \"\"\"Raised when the version of the device does not support command.\"\"\"\n\n    pass\n</code></pre>"},{"location":"device-reference/#pyalicat.device.all_subclasses","title":"<code>all_subclasses(cls)</code>","text":"<p>Returns all subclasses of a class.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>class</code> <p>The class to get the subclasses of.</p> required <p>Returns:</p> Name Type Description <code>set</code> <code>set[type]</code> <p>The set of subclasses.</p> Source code in <code>pyalicat/device.py</code> <pre><code>def all_subclasses(cls: type) -&gt; set[type]:\n    \"\"\"Returns all subclasses of a class.\n\n    Args:\n        cls (class): The class to get the subclasses of.\n\n    Returns:\n        set: The set of subclasses.\n    \"\"\"\n    return set(cls.__subclasses__()).union(\n        [s for c in cls.__subclasses__() for s in all_subclasses(c)]\n    )\n</code></pre>"}]}